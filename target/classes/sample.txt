Programação orientada
a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Joaquim Pessôa Filho

Pessôa Filho, Joaquim
Programação orientada a objetos com C# / Joaquim Pessôa Filho.
– São Paulo : Editora Senac São Paulo, 2023. (Série universitária)
Bibliografia.
e-ISBN 978-85-396-5172-6 (ePub/2023)
e-ISBN 978-85-396-5171-9 (PDF/2023)
1. Desenvolvimento de sistemas 2. Linguagem de programação
3. Programação orientada a objetos 4. Software (desenvolvimento)
5. Linguagem C# 6. C# I. Título. II. Série
23-1912g




CDD – 003
005.13
BISAC COM051210
COM051000
Índice para catálogo sistemático
1. Desenvolvimento de sistemas 003
2. Linguagem de programação 005.13

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Dados Internacionais de Catalogação na Publicação (CIP)
(Simone M. P. Vieira - CRB 8ª/4771)

Joaquim Pessôa Filho

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

PROGRAMAÇÃO ORIENTADA
A OBJETOS COM C#

Presidente do Conselho Regional
Abram Szajman
Diretor do Departamento Regional
Luiz Francisco de A. Salgado
Superintendente Universitário e de Desenvolvimento
Luiz Carlos Dourado

Editora Senac São Paulo
Conselho Editorial
Luiz Francisco de A. Salgado
Luiz Carlos Dourado
Darcio Sayad Maia
Lucila Mara Sbrana Sciotti
Luís Américo Tousi Botelho
Gerente/Publisher
Luís Américo Tousi Botelho
Coordenação Editorial
Ricardo Diana
Prospecção
Dolores Crisci Manzano
Administrativo
Verônica Pirani de Oliveira
Comercial
Aldair Novais Pereira
Coordenação de Arte
Antonio Carlos De Angelis
Coordenação de E-books
Rodolfo Santana
Coordenação de Revisão de Texto
Janaina Lira
Acompanhamento Pedagógico
Mônica Rodrigues
Designer Educacional
Juliana Falsetti
Revisão Técnica
Gustavo Calixto
Preparação e Revisão de Texto
Caique Zen Osaka
Projeto Gráfico
Alexandre Lemes da Silva
Emília Corrêa Abreu
Capa
Antonio Carlos De Angelis
Editoração Eletrônica
Gabriel Dantas Arrais
Ilustrações
Gabriel Dantas Arrais
Imagens
Adobe Stock Photos

Proibida a reprodução sem autorização expressa.
Todos os direitos desta edição reservados à
Editora Senac São Paulo
Av. Engenheiro Eusébio Stevaux, 823 – Prédio Editora –
Jurubatuba – CEP 04696-000 – São Paulo – SP
Tel. (11) 2187‑4450
editora@sp.senac.br
https://www.editorasenacsp.com.br
© Editora Senac São Paulo, 2023

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Administração Regional do Senac no Estado de São Paulo

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Sumário

Capítulo 1
Fundamentos da programação
orientada a objetos, 7
1 Orientação a objetos: um jeito de
olhar o mundo, 8
2 Definição de objetos, 9
3 Definição de classes, 10
4 Definição de abstração,
encapsulamento, herança e
polimorfismo, 14
5 Apresentação dos conceitos de
análise, design e programação
orientada a objetos, 17
6 Introdução à UML, 18
Considerações finais, 20
Referências, 21

Capítulo 2
Objetos, classes e métodos, 23
1 Encapsulamento: definição e uso, 24
2 Definição de classes e métodos:
inicialização com construtores, 29
3 Mensagens, inicialização e
instanciamento de objetos, 35
Considerações finais, 39
Referências, 40

Capítulo 3
Herança e polimorfismo, 41
1 Introdução ao conceito de
herança, 42
2 Formas de herança, 43
3 Benefícios de herança, 46
4 Introdução ao conceito de
polimorfismo, 49
5 Sobrecarga de métodos e
substituição (overriding), 51
Considerações finais, 54
Referências, 55

Capítulo 4
Definição de requisitos, 57
1 Introdução a requisitos e suas
definições, 58
2 Apresentação dos requisitos
FURPS+, 60
Considerações finais, 67
Referências, 67

Capítulo 5
Introdução a casos de uso, 69
1 Introdução a atores, 70
2 Introdução a cenários, 71
3 Introdução a diagramas, 74
Considerações finais, 77
Referências, 78

Capítulo 6
Modelagem conceitual, 79
1 Introdução à modelagem
conceitual, 80
Considerações finais, 86
Referências, 86

Capítulo 7
Diagramas de classe, 87
1 Introdução aos diagramas de
classe, 88
2 Exemplos de uso em ambiente de
jogos digitais, 95
Considerações finais, 101
Referências, 102

Anexos

Anexo I, 103
Anexo II, 104
Anexo III, 105

1 Padrões de projetos, 108
Considerações finais, 118
Referências, 118

Sobre o autor, 121

6

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Capítulo 8
Introdução a padrões de
projetos, 107

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Capítulo 1

Fundamentos
da programação
orientada a objetos

Bem-vindo ao mundo da orientação a objetos. Neste capítulo faremos uma viagem abrangente por esse mundo, partindo de algumas
perguntas: o que são objetos? Como representá-los através de classes?
Além disso, você será apresentado a uma visão geral sobre outros conceitos-chave relacionados ao assunto, como abstração, encapsulamento, herança e polimorfismo.
No desenvolvimento de softwares complexos, é importante ter ferramentas para projetar o que será feito. Por isso, estudaremos também
os primeiros passos na criação de diagramas UML (unified modeling
language), que ajudam pessoas de negócio e desenvolvedores a ter
uma visão do software a ser desenvolvido.
7

guagem de programação C#, criada e mantida pela Microsoft.

1 Orientação a objetos: um jeito de
olhar o mundo
A programação orientada a objetos (POO) é um jeito de olhar o mundo e buscar soluções computacionais (programas) para suas necessidades. Há várias formas de pensar a construção de um programa, e
a elas damos o nome de “paradigmas de linguagem de programação”.
Entre esses paradigmas, a POO é um dos mais difundidos atualmente.
Pensar nas coisas do nosso mundo como objetos é algo natural
para o ser humano. Com a POO, pensamos nos programas de computadores utilizando representações de grupos de objetos do mundo
real, levando em conta seus comportamentos (funções) e suas características (atributos).
Na orientação a objetos, a grande questão é desenvolver técnicas
de abstração do mundo real, ou seja, conseguir converter as coisas
que vemos para um trecho de código que tenha as características e
os comportamentos desejados e reproduza o objeto do mundo real no
nosso programa.

PARA PENSAR
Já parou para pensar como representar um personagem de um jogo em
um programa de computador? E se esse personagem coleta itens, que
podem ser usados em sua aventura, como seria a relação desses itens
com a representação do personagem?

8

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Todos esses conceitos e técnicas serão abordados utilizando a lin-

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Nas próximas seções você poderá se aprofundar mais nesses conceitos e entender o mundo fascinante da orientação a objetos. Como
são as linguagens de programação online orientada a objetos? Quais
recursos elas oferecem?

2 Definição de objetos
Nosso mundo é composto por diversos objetos, mas será que sabemos definir o que é objeto? Segundo o dicionário online Dicio, um objeto
é uma “coisa material que pode ser percebida pelos sentidos (visão, audição, tato, olfato e paladar): uma bola é um objeto, um lápis é um objeto, um celular é um objeto” (OBJETO, 2023). Partindo dessa definição,
percebemos que praticamente qualquer coisa pode ser um objeto, algo
que conseguimos ver, ouvir, tocar ou até mesmo comer e cheirar.
Como no exemplo do dicionário, uma bola é um objeto. Mas uma
bola tem uma cor, uma textura, pode ou não ter desenhos, e é feita com
algum material específico. Logo, é importante entender que podemos
ter uma coleção de bolas, mas cada uma terá características diferentes.
Um colecionador de selos postais possui diversos selos diferentes,
na cor, no formato, no país de origem e no material de fabricação. Você
saberia classificar esses selos? Qual critério usaria? Cada selo é um
objeto diferente e pode ser diferenciado de outro por um conjunto de
atributos. Mas que atributos seriam esses?
Segundo a Federação Brasileira de Filatelia ([s. d.]), as formas mais
comuns de classificar selos postais são: por país, por data de emissão,
por tipo de picote das bordas e pela marca d’água, entre outras. Se você
não conhece muito sobre selos, provavelmente pensou em outras formas de classificá-los, e isso é normal.
Segundo Barnes e Kölling (2010), “os objetos podem ser categorizados e uma classe descreve – de maneira abstrata – todos os objetos
de um tipo particular”. Categorizar os objetos é um passo importante
Fundamentos da programação orientada a objetos

9

IMPORTANTE
Lembre-se: um objeto não é uma definição genérica sobre algo, mas
uma coisa material. Uma bola vermelha de borracha é um objeto, e
uma bola branca com detalhes pretos e fabricada com couro é outro
objeto. Ainda que as duas sejam bolas (mesma categoria), trata-se de
objetos distintos.

3 Definição de classes
Já sabemos que objetos são coisas específicas do mundo real.
Como no exemplo do quadro “Importante”, uma bola vermelha de borracha é um objeto, e uma bola branca com detalhes pretos e fabricada
em couro é outro objeto, mas podemos chamar as duas de “bola”. Quais
são as características comuns entre elas? O que as define como bola?
Pensar em classes é construir uma representação genérica de um
conjunto de objetos. Voltando ao nosso exemplo, uma bola pode ser definida como uma classe que possui os atributos cor e material. Ao criar formalmente essa representação genérica, estamos definindo uma classe,
mas, se dermos valores aos atributos, estamos definindo objetos.
Neste livro usaremos a linguagem C# para construir nossos programas, das nossas classes (MICROSOFT, 2022). Essa linguagem teve sua
primeira versão em 2002 e era muito parecida com a linguagem Java,
também orientada a objetos. Desde sua primeira versão, a linguagem já
possuía os recursos mínimos que usaremos aqui, mas hoje, depois de
evoluir muito, ela conta com diversos recursos mais modernos. Hoje,
10

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

quando queremos representá-los em um programa de computador. No
entanto, um mesmo objeto pode ser visto de perspectivas diferentes, a
depender do observador.

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

com C#, podemos construir aplicações desktop, servidores e até mesmo jogos.
Mas, afinal, do que uma classe é composta? Como fazer isso em
código? Bem, em C#, mas não só nessa linguagem, primeiramente uma
classe deve ter um nome que a represente, mas, além do nome, ela
pode ter:
• campos/atributos/propriedades, que representam as características da classe (por exemplo, para uma cadeira, um campo pode
ser a quantidade de pernas, e outro campo pode ser o material
de fabricação);
• métodos, que representam o comportamento de uma classe (por
exemplo, a classe Calculadora possui métodos como somar, subtrair, etc., enquanto para a classe Cachorro um método possível
poderia ser latir); e
• construtores, métodos especiais que inicializam uma classe
no momento de sua criação (veremos mais sobre construtores na prática).

IMPORTANTE
O nome das classes deve ter um significado evidente, pois é por meio do
nome que temos o primeiro contato com ela. Se você está criando uma
classe para representar um aluno, chame a classe de Aluno, pois assim,
ao ver o nome da classe, outros desenvolvedores já entenderão a quais
objetos do mundo real ela se refere.

E o código? Vamos construir uma classe para representar uma conta bancária. Nossa conta bancária deve possuir um saldo e permitir
as ações de consultar, depositar e sacar. Com essas regras podemos
construir a seguinte representação de classe em C# (Código 1).
Fundamentos da programação orientada a objetos

11

totalmente online? O Replit, acessível em replit.com, é um bom exemplo. Com essa ferramenta gratuita, você consegue experimentar todos
os códigos que serão apresentados aqui. A vantagem de ferramentas
online como essa é que com elas podemos programar até mesmo do
nosso celular.
class ContaBancaria {
double valor = 0;
public void depositar(double deposito) {
if(deposito > 0) {
valor = valor + deposito;
}
}
public void sacar(double saque) {
valor = valor - saque;
}
public double saldo(){
return valor;
}
}

A nossa classe se chama ContaBancaria e possui um atributo valor
do tipo double (número com casas decimais). Além disso, dispõe de
três métodos públicos que implementam a lógica solicitada.
Se analisarmos com cuidado essa classe, veremos que é permitido
sacar qualquer valor, mesmo que esse seja maior do que o saldo. Além
disso, podemos depositar valores negativos. Isso está certo? Depende
da situação. Para ficarmos mais próximos da realidade a que estamos
acostumados, vamos alterar a classe, permitindo somente depósitos
de valores maiores que zero e saques que não deixem o valor da conta
no negativo:
12

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Você sabia que podemos programar em C# usando ferramentas

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

class ContaBancaria {
double valor = 0;
public void depositar(double deposito) {
if(deposito > 0) {
valor = valor + deposito;
}
}
public void sacar(double saque) {
if(saque <= valor) {
valor = valor - saque;
}
}
public double saldo(){
return valor;
}
}

Agora que temos a classe ContaBancaria, podemos criar um código
usando essa nossa representação. Veja o código da classe Principal:
class Principal {
static void Main(string[] args) {
ContaBancaria conta = new ContaBancaria();
Console.WriteLine("Saldo: " + conta.saldo());
conta.depositar(10.0);
conta.sacar(3.0);
conta.sacar(35.10);
Console.WriteLine("Novo saldo: " + conta.saldo());
}
}

Fundamentos da programação orientada a objetos

13

Chamamos de “abstração” o processo de representar os objetos
do mundo real (seus atributos e comportamentos) através de classes.
Segundo Barnes e Kölling (2010, p. 50), “abstração é a capacidade de
ignorar detalhes das partes para focalizar a atenção em um nível mais
elevado de um problema”.
Figura 1 – Abstração: foco nas características essenciais do objeto conforme
a perspectiva do observador

Fonte: adaptado de Booch et al. (2007).

Na figura 1, duas pessoas olham de modo diferente para o mesmo
objeto. A senhorinha foca em detalhes de seu interesse, ou seja, o quão
fofinho é o gato, enquanto a veterinária, com seu olhar técnico, visualiza o esqueleto do animal. De forma semelhante, o modelo abstrato que
construímos para usar em nossos programas não será necessariamente o mesmo de outros programadores, pois esse modelo depende dos
14

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

4 Definição de abstração, encapsulamento,
herança e polimorfismo

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

detalhes que queremos focar e de quem está projetando o sistema. No
código da seção anterior, criamos uma conta bancária focada somente
nos elementos em que tínhamos interesse. Porém, se você for implementar um sistema para um banco de verdade, verá que não há somente
um tipo de conta bancária, e que esta não contém apenas o atributo de
guardar o saldo.
Além da abstração, outro fator importante na programação orientada a objetos é o encapsulamento. Essa técnica permite esconder os
detalhes de implementação de uma classe.
Figura 2 – Ideia de encapsulamento

A figura 2 mostra como um carro é composto por partes, como o
motor, que só podemos ver quando abrimos o capô. No encapsulamento, como no carro, criamos uma forma de esconder outras classes. Por
exemplo, no caso da conta bancária, escondemos a lógica usada para
fazer depósitos e saques.
Observe as duas possíveis classes ContaBancaria nos códigos a seguir (a e b). Os métodos públicos são as únicas coisas que podem ser

Fundamentos da programação orientada a objetos

15

talhes de implementação estão escondidos. Embora os nomes sejam
os mesmos, veja que os resultados são diferentes, visto que o código
b possui um limite que vai além do saldo, e o código a só permite sacar
valores que não excedam o saldo existente.
(a)

class ContaBancaria {
double valor = 0;
public void sacar(double saque) {
if(saque <= valor) {
valor = valor - saque;
}
}
// código omitido para não tirar a atenção do assunto
}
(b)

class ContaBancaria {
double valor = 0;
double limite = 200;
public void sacar(double saque) {
if(saque <= (valor + limite) {
valor = valor - saque;
}
}
// código omitido para não tirar a atenção do assunto
}

Além da diferença no método sacar, o código b tem um atributo limite que não existe no outro código. Note que em ambos os códigos os
atributos não possuem a palavra public. Em C#, isso significa que os
atributos são privados.

16

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

usadas fora da classe, por exemplo no método main. Com isso, os de-

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Atributos e métodos private só podem ser acessados dentro da classe em que foram declarados, enquanto atributos descritos como public
(públicos) podem ser acessados dentro e fora da classe. Com esses
controles de acesso, conseguimos implementar a técnica de encapsulamento (nos aprofundaremos nesse assunto no capítulo 2).
Quando projetamos as classes, usamos a herança e o polimorfismo
para construir programas melhores. A herança permite criar classes que
herdam comportamentos e atributos de outra classe, mas possibilitando
que as classes filhas tenham comportamentos especializados – ou seja,
além da herança, essas novas classes podem definir novos métodos e
atributos. Já o polimorfismo é uma técnica bem útil para mudar comportamentos nas classes filhas ou até mesmo para permitir a interação
entre classes que não se conhecem.
Tudo isso parece muito abstrato? Bem, fique tranquilo, pois também
estudaremos mais a fundo a herança e o polimorfismo mais adiante, no
capítulo 3.

5 Apresentação dos conceitos de análise,
design e programação orientada a objetos
Agora que tratamos dos principais conceitos de objeto, precisamos entender como projetar nosso sistema, como construir sua
arquitetura. Na POO, o design orientado a objetos (OOD, do inglês
object-oriented design) ajuda a projetar e a modelar o sistema. Nesse
ponto, trabalhamos com o modelo conceitual do sistema a fim de identificar, definir e projetar classes e objetos de um sistema complexo, bem
como seu relacionamento e implementação.
Segundo Barnes e Kölling (2010, p. 248), “uma forte visão arquitetônica é algo comum a praticamente todos os sistemas orientados a
objetos bem-sucedidos que encontramos”. Mas como construir um sistema orientado a objetos bem-sucedido? Até agora aprendemos como
Fundamentos da programação orientada a objetos

17

do nosso sistema, e é aí que o design entra em ação, nos ajudando a
analisar e construir o modelo de uma classe. Nos exemplos anteriores
construímos classes importantes para resolver o problema em questão,
mas seriam elas as melhores classes, ou as únicas necessárias, para
nosso programa?
A etapa de análise e design é fundamental para executar bem o projeto de software. As escolhas feitas nessa etapa definem a qualidade do
sistema. No capítulo 4 veremos como analisar o problema, criar boas
classes e implementá-las.

6 Introdução à UML
De acordo com Fowler (2005, p. 25), “UML (Unified Modeling
Language) é uma família de notações gráficas, apoiada por um metamodelo único, que ajuda na descrição e no projeto de sistemas de software”. Assim, a UML é um modo de modelar e desenhar sistemas de
forma gráfica que nos ajuda a representar as abstrações dos objetos a
fim de facilitar discussões e até implementar classes.
Há algumas formas de utilizar a UML: esboço, projeto e linguagem de programação. Entre os desenvolvedores, a mais comum é
o esboço, que ajuda a transmitir aspectos fundamentais e ações
do sistema. Nessa fase do projeto, pode-se esboçar ideias ou alternativas do que se está prestes a desenvolver, bem como explicar o
funcionamento de alguma parte do sistema (por exemplo, “clientes
podem abrir X contas”).
Usando a UML como projeto, o foco será a qualidade, a fim de construir e modelar o esquema completo, expondo todas as ações e decisões, para que o programador consiga segui-las de modo claro e direto,
e resumindo e esclarecendo as funcionalidades. Já ao utilizar a UML

18

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

construir objetos e classes, mas antes precisamos encontrar as classes

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

como linguagem de programação, os desenvolvedores constroem diagramas UML compilados diretamente para o código executável.
Independentemente da forma de utilização, podemos dizer que a essência da UML é o metamodelo: um diagrama, geralmente de classes,
que define os conceitos de linguagem.

PARA SABER MAIS
A história da UML remonta à década de 1980, quando já havia diversas
linguagens para modelos de dados. Porém, foi na metade da década de
1990 que Grady Booch, Ivar Jacobson e James Rumbaugh, criadores de
métodos orientados a objetos, começaram a reunir as melhores ideias e
criaram uma linguagem unificada de modelagem. Mas essa história não
para por aí. Para conhecer mais sobre a criação da UML, leia obras de
Grady Booch, Peter Coad, Ivar Jacobson, Jim Odell e James Rumbaugh,
que são essenciais na bibliografia sobre linguagens gráficas de modelagem orientadas a objetos. Entre essas obras, recomendamos especialmente Object-oriented analysis and design with applications, de Booch
et al. (2007).

A construção do metamodelo ou a execução da modelagem de dados possui uma notação e sintaxe específica para construção de ideias,
conforme figura 3, podemos ver uma pequena parte, com classes e
seus relacionamentos do exemplo de conta bancária utilizado no subcapítulo anterior.

Fundamentos da programação orientada a objetos

19

Nos próximos capítulos veremos mais a fundo as notações e construções de modelos em UML. Uma recomendação importante de Fowler
(2005) é se concentrar primeiro nas formas básicas de diagramas de
classes e de sequência e, quando os tiver dominado, avançar para diagramas mais sofisticados e avançados. Essa recomendação pode parecer óbvia, mas é sempre importante reforçar a importância de entender
e seguir os passos necessários corretamente.

Considerações finais
Neste capítulo vimos que a orientação a objetos permite criar programas de computador de forma muito próxima a como fazemos as
coisas fora do computador. Vimos ainda que pensar de forma abstrata
é essencial para elaborar classes com clareza, a fim de que elas representem somente aquilo que desejamos processar em nossa aplicação.
Outro ponto importante abordado é a necessidade de planejar o desenvolvimento antes de começar a construir o código. Para isso, a UML

20

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Figura 3 – Metamodelo UML da classe ContaBancaria

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

se apresenta como uma importante ferramenta, não só para projetar o
que será feito como para documentar o que já foi feito.

Referências
BARNES, David J.; KÖLLING, Michael. Programação orientada a objetos com
Java: uma introdução prática usando o BlueJ. São Paulo: Pearson, 2010.
BOOCH, Grady et al. Object-oriented analysis and design with applications.
Boston: Addison-Wesley, 2007.
FEDERAÇÃO BRASILEIRA DE FILATELIA (FEBRAF). Página inicial. Febraf, [s. d.].
Disponível em: https://www.febraf.com.br/. Acesso em: 12 maio 2023.
FOWLER, Martin. UML essencial: um breve guia para a linguagem-padrão de
modelagem de objetos. Porto Alegre: Bookman, 2005.
MICROSOFT. O histórico da linguagem C#. Microsoft Learn, 2022. Disponível em:
https://learn.microsoft.com/pt-br/dotnet/csharp/whats-new/csharp-version-history. Acesso em: 16 set. 2022.
OBJETO. In: DICIO: dicionário online de português. Porto: 7Graus, 2023.
Disponível em: https://www.dicio.com.br/objeto/. Acesso em: 12 maio 2022.
REPLIT. Página inicial. Replit, [s. d.]. Disponível em: https://replit.com/. Acesso
em: 15 maio 2023.

Fundamentos da programação orientada a objetos

21

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Capítulo 2

Objetos, classes
e métodos

No capítulo anterior, estudamos de forma resumida o que é orientação a objetos, objeto e classes, entre outros temas. Agora é hora de nos
aprofundarmos em alguns desses pontos. Com a linguagem C#, abordaremos de forma prática a criação de objetos e como usar a técnica de
encapsulamento para melhorar um código.
23

Você se lembra da definição de objeto do capítulo anterior? Objeto
é qualquer coisa que pode ser percebida por um ou mais dos nossos
sentidos. Partindo dessa definição, podemos descrever objetos específicos. Porém, na POO, os objetos devem ser descritos de forma genérica, e é aí que entram as classes.
Na linguagem C#, classe é uma descrição genérica de um conjunto de objetos a partir do ponto de vista do desenvolvedor/arquiteto de
software. E, como vimos, as propriedades de um conjunto de objetos
podem variar a depender do propósito. Vamos lá: imagine que você
deseja projetar um jogo de guerra entre dois oponentes. Cada pessoa
pode pensar numa forma diferente de representar esses oponentes.
A figura 1, por exemplo, ilustra uma heroína e um vilão, dois personagens possíveis para o jogo.
Figura 1 – Exemplo de personagens

Se eu fosse o desenvolvedor, poderia registrar no meu sistema as
propriedades “usa capa?”, cor do uniforme e tipo de personagem (herói
ou vilão), entre outras. Outra pessoa, porém, pode registrar propriedades diferentes, e por isso é importante entender o propósito do sistema.

24

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

1 Encapsulamento: definição e uso

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Para seguir, vamos usar a propriedade “tipo de personagem”, mencionada anteriormente.
Quando definimos a classe Personagem, queremos que os dados
dela sejam guardados em um objeto, em memória, e que os atributos
tenham valores consistentes. Por exemplo, se guardarmos o tipo de
personagem (herói ou vilão), precisamos impedir que valores inválidos
sejam informados. Nesse caso, o encapsulamento é importante. Além
disso, desejamos agrupar com esses dados os comportamentos associados ao objeto.
Encapsulamento de dados, segundo Page-Jones (2001), é um conceito tão antigo quanto o de software. Em POO, o termo encapsulamento se refere às classes, nas quais conseguimos reunir, sob um mesmo
nome, um conjunto de atributos (propriedades do objeto) e funções
(comportamento dos objetos).
No código a seguir, a classe Personagem encapsula um único atributo, “tipo”, que é uma string:
class Personagem{
// herói ou vilão
public string tipo;
}
class Programa {
static void Main() {
Personagem thor = new Personagem();
thor.tipo = "herói";
Console.WriteLine("O personagem é do tipo " + thor.
tipo);
}
}

Nesse código, o método main cria uma instância da classe
Personagem utilizando a palavra reservada “new” do C#. Ao criar uma
Objetos, classes e métodos

25

sível ter várias instâncias de uma classe, que são diferenciadas pelos
valores de seus atributos, como no código a seguir:
Personagem thor = new Personagem();
Personagem capitaMarvel = new Personagem();
Personagem marioBros = new Personagem();

Nesse código criamos três instâncias diferentes a partir da mesma classe. Da forma como definimos a classe Personagem, podemos
colocar qualquer valor no atributo tipo das instâncias de Personagem.
Acompanhe o exemplo a seguir:
Personagem thor = new Personagem();
thor.tipo = "qualquer coisa";

Pelo nome da variável, o tipo do personagem deveria ser herói, mas,
como o atributo da classe é público, podemos colocar “qualquer coisa”
nesse atributo. Como resolver isso? Com o encapsulamento, podemos
controlar o acesso aos atributos usando modificadores. Em C#, temos
cinco diferentes modificadores de acesso. Neste material, abordaremos
os dois mais utilizados:
• public: acesso público, qualquer outra classe tem acesso; e
• private: somente a classe a qual pertence tem acesso.
Com os modificadores de acesso podemos resolver o problema
apresentado. O encapsulamento permite ocultar aspectos internos,
como no caso do atributo tipo. Para que a classe Personagem aceite
somente os tipos herói e vilão, temos que deixar seus atributos privados
(ocultos para o mundo externo à classe) e criar funções/métodos públicos (métodos de acesso para o mundo externo à classe) que acessem e
alterem esses atributos. Nessas funções colocamos lógica e validações
dos dados. Acompanhe a implementação:

26

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

instância, definimos valores aos atributos da classe. Com isso, é pos-

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

class Personagem {
// atributo privado que guarda o valor
// somente a classe tem acesso
private string tipo;
// métodos (Get e Set) públicos para acesso ao
// atributo privado. Desta forma o
// atributo está encapsulado na classe
public void SetTipo(string tipo) {
if (String.Equals(tipo, "herói") || String.
Equals(tipo, "vilão")) {
this.tipo = tipo;
} else {
this.tipo = "desconhecido";
}
}
public string GetTipo() {
return this.tipo;
}
}
class Programa {
static void Main() {
Personagem loki = new Personagem();
loki.SetTipo("Qualquer coisa");
string tipo = loki.GetTipo();
Console.WriteLine("O personagem é do tipo" + tipo);
}
}

Quando definimos um atributo como private, ele só pode ser acessado dentro da própria classe, por isso não é possível acessá-lo da
classe Programa. Porém, criamos dois métodos públicos, um para
mudar o valor do atributo e outro para ler. O método SetTipo recebe o
valor que desejamos adicionar e, no nosso exemplo, os únicos valores
possíveis são herói ou vilão. Por isso essa lógica está implementada,
impedindo que nosso atributo tipo tenha qualquer outro valor. Caso o
usuário informe “qualquer coisa”, nosso método colocará o tipo como

Objetos, classes e métodos

27

Outra forma de fazer o controle de acesso é através de atributos especiais que definem internamente os métodos get e set. O código a seguir tem o mesmo comportamento do anterior, mas dessa vez usando
um atributo especial a que demos o nome de Tipo (com T maiúsculo),
o qual possui as funções set (quando você troca o valor) e get (para
quando deseja ler o valor).
class Personagem {
// atributo privado que guarda o valor
// somente a classe tem acesso
private string tipo = "desconhecido";
// atributo público com metodos de
// acesso set e get. Desta forma o
// atributo está encapsulado na classe
public string Tipo {
set {
if (String.Equals(value, "herói") || String.
Equals(value, "vilão")) {
tipo = value;
} else {
tipo = "desconhecido";
}
}
get {
return this.tipo;
}
}
}

Note que nessa implementação não precisamos dos métodos públicos, pois o atributo Tipo (com T maiúsculo) já é público e contém os
métodos de acesso get e set. E, ah, criar o atributo com o mesmo nome
é uma boa prática! Note também que a função set tem uma variável

28

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

“desconhecido”. Por isso, na última linha do código será impressa a
mensagem “O personagem é do tipo desconhecido”.

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

value que contém o valor que foi atribuído. Para a usarmos, fazemos
como em um atributo comum. Acompanhe o código a seguir:
Personagem thor = new Personagem();
thor.Tipo = "herói";
Personagem loki = new Personagem();
loki.Tipo = "não sei";
Console.WriteLine("Personagem Thor é do tipo " + thor.Tipo);
Console.WriteLine("Personagem Loki é do tipo " + loki.Tipo);

2 Definição de classes e métodos:
inicialização com construtores
Nas classes que estudamos até aqui, os atributos só são acessíveis
se criarmos uma instância da classe. Por exemplo, no código da classe
Personagem, criamos uma variável chamada thor, que guarda uma instância diferente da variável loki. Cada uma delas possui o atributo Tipo,
mas os valores são diferentes:
Personagem thor = new Personagem();
thor.Tipo = "herói";
Personagem loki = new Personagem();
loki.Tipo = "não sei";

Outro recurso na programação orientada a objetos é o modificador
static, que permite criar atributos e métodos estáticos, os quais pertencem à classe, e não à instância. Por isso, para acessá-los, não precisamos de uma variável contendo uma instância, como no exemplo anterior. Um exemplo de uso em jogos poderia ser aplicado à classe Inimigo,
como no código a seguir:
class Inimigo{
public static double VidaMaxima = 100.0;

Objetos, classes e métodos

29

Inimigo monstro = new Inimigo();
monstro.Vida = monstro.Vida + 100;
// saída: A vida do monstro é 100
Console.WriteLine("A vida do monstro é " + monstro.Vida);

Note no exemplo a seguir a forma diferente de acesso de um atributo
estático (VidaMaxima) e de outro não estático (Vida).
Inimigo monstro1 = new Inimigo();
Inimigo monstro2 = new Inimigo();
monstro1.Vida = monstro1.Vida + 100;
Inimigo.VidaMaxima = 200.0;
monstro2.Vida = monstro2.Vida + 100;

30

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Na definição da classe Inimigo, criamos um atributo estático chamado VidaMaxima, que representará o que o seu nome indica: o máximo de
vida que um inimigo pode ter. Note que, no método set do atributo Vida,
fazemos um teste para verificar se o valor informado é maior que a vida
máxima. Se for verdade, em vez de atribuir o novo valor de vida, usamos
o valor máximo, impedindo que ele seja ultrapassado. Implementadas
dessa forma, todas as instâncias de inimigos terão exatamente a mesma quantidade de vida máxima.

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

// saída:
// A vida do monstro1 é 100 de 200
// A vida do monstro2 é 150 de 200
Console.WriteLine("A vida do monstro1 é " + monstro1.Vida + "
de " + Inimigo.VidaMaxima);
Console.WriteLine("A vida do monstro2 é " + monstro2.Vida + "
de " + Inimigo.VidaMaxima);

Nesse exemplo, o monstro 1 tem sua vida incrementada em 100,
mas, como no momento da execução a vida máxima permitida era 100,
o monstro 1 ficou com a vida limitada a esse valor. Já o monstro 2 teve
sua vida incrementada em 100, mas depois que mudamos o valor de
vida máxima de um inimigo para 200:
Inimigo.VidaMaxima = 200.0;

Note que, para acessar o atributo VidaMaxima, antes usamos o nome
da classe, e não da variável, que guarda a instância. Isso porque se trata
de um atributo estático, que é igual independentemente da instância.
A mesma lógica pode ser aplicada aos métodos. Um método estático pertence à classe, e não à instância, e é muito útil para criar, por
exemplo, uma classe Calculadora, que normalmente não depende dos
atributos da classe. Acompanhe o exemplo:
class Calculadora {
public static double soma(double a, double b) {
return a+b;
}
public static double subtracao(double a, double b) {
return a-b;
}
}

Para usar essa calculadora, não precisamos da instância. Basta fazer como no exemplo:

Objetos, classes e métodos

31

Console.WriteLine("Soma = " + resultado1); // 33,5
Console.WriteLine("Subtracao = " + resultado2); //-13,5

Na prática não precisamos de uma classe Calculadora como essa,
mas de métodos estáticos sim. Em jogos, por exemplo, nossa calculadora pode ser uma classe com métodos que calculem rota de inimigos
pelo mapa. Um dos métodos estáticos pode retornar o menor caminho
entre o jogador e o inimigo, para que ele possa persegui-lo.
Para criar uma instância, você percebeu que até agora usamos a palavra reservada “new”, seguida do nome da classe e parênteses?
Inimigo monstro1 = new Inimigo();
Inimigo monstro2 = new Inimigo();

Assim estamos dizendo ao C# que queremos criar uma instância
da classe Inimigo e, para isso, indicamos o uso de um construto sem
parâmetros (nosso exemplo).
Segundo Barnes e Kölling (2010), os construtores têm a função de
colocar a instância de uma classe em um estado previamente definido.
Eles são usados sempre que criamos uma instância da nossa classe.
Como vimos anteriormente, classe é a abstração de um grupo de objetos do mundo real, e é descrita por seus atributos e comportamentos.
Uma instância é a representação de um objeto específico, ou seja, criamos uma variável do tipo que desejamos (classe), que armazenará os
valores específicos do objeto desejado, e esses valores são vinculados
a seus atributos.
Considere a definição da classe Inimigo que contém os atributos
vida (com v minúsculo e não estático) e VidaMaxima (estático) e os

32

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

double resultado1 = Calculadora.soma(10.0,23.5);
double resultado2 = Calculadora.subtracao(10.0, 23.5);

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

métodos de acesso get e set através do atributo Vida. Para criar uma
instância dessa classe, escrevemos o comando:
Inimigo monstro = new Inimigo();

Nessa linha criamos uma variável de nome monstro e usamos um
comando especial do C#, o new, para criar uma instância de Inimigo.
O Inimigo() é nosso construtor! Você pode estar se perguntando em que
lugar o escrevemos, não? Bem, todas as classes têm construtor, mesmo que você não o escreva. Nesse caso, o C# disponibiliza o construtor-padrão, um método sem nenhum parâmetro e com o mesmo nome
da classe. Mas, se quisermos criar nosso construtor, isso é possível.
Acompanhe a alteração feita na classe Inimigo:
class Inimigo {
public static double VidaMaxima = 100.0;
private double vida;
public double Vida {
set {
if (value > Inimigo.VidaMaxima) {
vida = VidaMaxima;
} else {
vida = value;
}
}
get{
return this.vida;
}
}
// Construtor-padrão que inicia um inimigo
// com a vida máxima
public Inimigo() {
vida = Inimigo.VidaMaxima;
}
// Construtor com parâmetro no qual informamos

Objetos, classes e métodos

33

O código a seguir mostra como usar esses construtores:
Inimigo monstro1 = new Inimigo();
Inimigo monstro2 = new Inimigo(200);
Inimigo monstro3 = new Inimigo(70);
Console.WriteLine("Monstro 1 tem " + monstro1.Vida + " de
vida");
Console.WriteLine("Monstro 2 tem " + monstro2.Vida + " de
vida");
Console.WriteLine("Monstro 3 tem " + monstro3.Vida + " de
vida");

A saída desse programa será:
Monstro 1 tem 100 de vida
Monstro 2 tem 100 de vida
Monstro 3 tem 70 de vida

Note que o monstro 2 teve sua vida limitada ao valor máximo, pois
o nosso construtor com parâmetro usa o atributo especial Vida (com V
maiúsculo) para definir a vida inicial.

34

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Nesse código foram criados dois construtores. Um deles é o construtor com parâmetro, que recebe o valor da vida inicial do nosso inimigo. Porém, quando criamos um construtor em nossa classe, o C#
não disponibiliza mais o construtor-padrão. Por isso também criamos
um construtor sem parâmetros, que inicializa a vida do inimigo com o
máximo permitido.

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

IMPORTANTE
1.

Os construtores recebem o mesmo nome da classe e são diferenciados uns dos outros por seus parâmetros.

2.

Uma classe pode não ter um construtor declarado, mas terá um
construtor-padrão, ou seja, um construtor sem parâmetros.

3.

Uma classe pode ter mais de um construtor, desde que sejam facilmente diferenciados por seus parâmetros.

4.

Os construtores são usados principalmente para inicializar os atributos de uma classe, seja com valores-padrão, seja com valores recebidos por parâmetro.

3 Mensagens, inicialização e instanciamento
de objetos
Como visto anteriormente, podemos criar construtores, métodos especiais invocados quando criamos uma instância de uma classe. Vimos
também que pode haver mais de um construtor, e que cabe ao desenvolvedor entender qual construtor usar ao criar uma instância a fim de
garantir que a classe possa ser usada em situações diversas.
Voltando ao exemplo do personagem, no momento da criação de
uma instância da classe Personagem, podemos estar num estágio em
que ainda não temos nenhum dado para atribuir à classe. Nesse caso,
usaremos o construtor sem parâmetros (construtor-padrão). Mas se
temos todos os dados, outro construtor pode ser usado, facilitando a
escrita do código.
A seguir, para complementar nossa classe Personagem, vamos descrever as propriedades nome e vida. Note que no C# temos a opção de
criar atributos autoimplementados:

Objetos, classes e métodos

35

public int Vida { get; set; }
private string tipo;
public string Tipo {
// omitido para ser breve
}
public Personagem() { }
public Personagem(string nome){
Nome = nome;
}
public Personagem(string nome, int vida, string tipo){
Nome = nome;
Vida = vida;
Tipo = tipo;
}
}

Note que se trata de atributos públicos, como os que fizemos antes,
mas dessa vez a declaração utiliza uma estrutura diferente: “tipo nomeDoAtributo { get; set; }”. Com essa estrutura é possível usar os construtores de outra maneira:


Na primeira linha usamos o construtor sem parâmetros, na sintaxe
do C#. Nesse caso, não colocamos parênteses e usamos as chaves
para nomear cada atributo e definir seus respectivos valores. Nos outros dois casos, foram usados construtores com parâmetros. No primeiro deles são passados somente o nome, a vida e o tipo, e usamos

36

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

class Personagem {
public string Nome { get; set; }

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

a mesma estrutura dos atributos autoimplementados. Já no segundo,
passamos todos os parâmetros da forma como vimos anteriormente.
Os inicializadores autoimplementados podem ser usados para permitir somente leitura para classes externas. Basta colocar o modificador de
acesso privado no método desejado, conforme o exemplo:
public string Nome { get; private set; }

Se mudarmos nosso código para que o set seja privado, o nome só
poderá ser alterado pelo construtor da classe, não sendo permitido atribuir valor do nome fora da definição da classe.
O interessante da orientação a objetos é que um objeto não é totalmente isolado de outro. Eles podem conversar através do método público, enviando e recebendo mensagens. Além disso, um objeto pode usar
outro para executar alguma ação. Acompanhe o exemplo:
class Arena {
public void dano(Personagem a, Personagem b) {
if (a.Tipo.Equals("herói")) {
// Se for herói infringindo dano em outro
// herói
if (b.Tipo.Equals("herói")) {
// Não da dano
return;
} else {
// Se for herói infringindo dano em
// um vilão
b.Vida = b.Vida - 10;
}
} else {
// Se for um vilão infringindo dano a outro
// vilão
if (b.Tipo.Equals("vilão")) {
// Não da dano
return;

Objetos, classes e métodos

37

Nesse exemplo criamos uma classe Arena. Para simplificar, colocamos somente um método chamado dano, que recebe dois objetos do
tipo Personagem como parâmetro a e b. Nessa assinatura, public é o
modificador de acesso, e void indica que essa função não tem nenhum
tipo de retorno. Agora você consegue entender o que o método faz?
Basicamente, implementamos uma lógica que calcula quanto de
dano um personagem infringirá a outro. Vilão não causa dano em vilão,
nem herói causa dano a outro herói. Se um herói atacar um vilão, o dano
será de –10. Já se um vilão atacar um herói, o dano é menor, –5:
b.Vida = b.Vida - 5;

Lemos da seguinte forma a linha acima: a vida de b é igual à vida de
b menos 5. Agora, como usamos essa lógica? Acompanhe o exemplo:
Personagem capitaMarvel = new Personagem { Nome = "Thanos",
Vida = 1000, Tipo = "herói" };
Personagem cruela = new Personagem { Nome = "Cruela Devil",
Vida = 100, Tipo = "vilão" };
Personagem nazare = new Personagem { Nome = "Nazaré Tedesco",
Vida = 100, Tipo = "vilão" };
Arena arena = new Arena();
arena.dano(capitaMarvel, cruela);
arena.dano(nazare, capitaMarvel);
arena.dano(cruela, nazare);
Console.WriteLine("Capitã Marvel: " + capitaMarvel.Vida);

38

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

			

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Console.WriteLine("Cruela Devil: " + cruela.Vida);
Console.WriteLine("Nazaré Tedesco: " + nazare.Vida);

Ao executar esse código a saída será:
Capitã Marvel: 995
Cruela Devil: 90
Nazaré Tedesco: 100

Ao chamarmos o método dano com as variáveis cruela e nazare, nenhum dano é infringido a nazare, pois ambas são do tipo vilão.
Nesse exemplo, se colocarmos o método dano como estático, como
ficaria seu uso? Veja a seguir:
class Arena {
public static void dano(Personagem a, Personagem b) {
// omitido para ser breve
}
}
...
Arena.dano(capitaMarvel, cruela);

Para o método ser estático, adicionamos o modificador static na
assinatura do método dano. Basta chamar o método diretamente da
classe. Não é preciso criar uma instância.

Considerações finais
Neste capítulo, entendemos o que é encapsulamento e como tratá-lo nas classes em C#, usando desde modificadores de acesso público
e privado até métodos e atributos estáticos. Entendemos também que
Objetos, classes e métodos

39

sáveis por entregar uma instância da nossa classe com um estado
predefinido. Por fim, vimos ainda que, na orientação a objetos, as instâncias das classes podem trocar mensagens através da invocação de
métodos.

Referências
BARNES, David J.; KÖLLING, Michael. Programação orientada a objetos com
Java: uma introdução prática usando o BlueJ. São Paulo: Pearson, 2010.
FOWLER, Martin. UML essencial: um breve guia para a linguagem-padrão de
modelagem de objetos. Porto Alegre: Bookman, 2005.
PAGE-JONES, Meilir. Fundamentos do desenho orientado a objetos com UML.
São Paulo: Makron Brooks, 2001.

40

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

uma classe pode ter mais de um construtor, e que eles são respon-

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Capítulo 3

Herança e
polimorfismo

Como vimos nos capítulos anteriores, a programação orientada a
objetos é uma forma de olhar o mundo. Por meio dela, criamos classes
que representam objetos, e tais classes têm atributos que são propriedades desses mesmos objetos, cujo comportamento nós representamos através de métodos.
41

sua maneira, a depender de sua perspectiva, e isso influencia como representamos uma classe e planejamos o encapsulamento dos dados.
Nesse processo, como aponta Fowler (2005), a hierarquia nos permite
classificar e organizar nossas abstrações. Ainda segundo o autor, existem dois tipos importantes de hierarquia, um relacionado à estrutura de
classes e outro à estrutura interna dos objetos.
Neste capítulo nos aprofundaremos na estrutura das classes, abordando o conceito de herança. Quando falamos de herança, logo vem
à nossa mente a ideia de gerações: nossos pais, avós, filhos. E, sim,
quando usamos esse termo em programação, estamos próximos dessa ideia, já que a palavra “herança” é usada para descrever o relacionamento entre classes. Uma classe herda características de uma ou mais
classes, assim como nós herdamos características genéticas dos nossos antepassados e as transferimos para nossos filhos e netos.

1 Introdução ao conceito de herança
A herança, um dos pilares da programação orientada a objetos, permite a nós, desenvolvedores, usar técnicas avançadas que facilitam a
manutenção e a reutilização do código (SCHILDT; SKRIEN, 2013).
A herança pertence às classes e permite passar características para
classes herdeiras. Por exemplo, podemos definir a classe Personagem
para representar qualquer tipo de personagem do nosso jogo, ou até
mesmo um personagem de outro jogo que venhamos a desenvolver.
Sabemos, porém, que muitos jogos precisam ter personagens com características específicas, ou até mesmo permitir que o jogador escolha
um tipo de personagem numa lista de diversos tipos, como nos jogos
de RPG (role playing game, jogo de interpretação de papéis).

42

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Vimos também que cada pessoa abstrai objetos do mundo real a

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Usando o exemplo dos personagens de RPG, podemos criar outras
classes, como Elfo, Duende e Humano, entre outras. Todos esses personagens compartilham algumas características e funções, e por isso
podemos usar a herança, a fim de colocar em uma única classe o que
é comum, e deixando o que é diferente somente nas classes herdeiras.

2 Formas de herança
Em C# temos alguns tipos de herança comuns em outras linguagens
orientadas a objetos. Temos a classe-base, ou pai, que fornece a herança, e temos a subclasse, ou classe derivada, que herda as características
da classe-base.
Mas o que é herdado? Veja o exemplo a seguir, em que temos a classe A como classe-base, e a classe B como subclasse.
1
2

using System;
class A {

3

public void Hello(){

4

Console.WriteLine("Hello world");

5

}

6

}

7

class B: A {

8

public void Ola() {

9

Console.WriteLine("Olá mundo");

10

}

11

}

12

class Programa {

13

static void Main() {

14

A a = new A();

15

B b = new B();

16

a.Hello();

17

b.Hello();

18
19
20

b.Ola();
}
}

Herança e polimorfismo

43

“Hello world”. A classe B possui o método Ola (linha 8), que diz “Olá mundo”. A linha 7 indica que a classe B é herdeira da classe A. Essa herança
é chamada de herança simples, pois envolve somente uma subclasse.
Na classe Programa, escrevemos o método Main (linha 13), para demonstrar os efeitos dessa herança. Veja que foram criadas duas instâncias, uma de A e outra de B (linhas 14 e 15). A instância de B, além de
saber dizer “Olá mundo”, sabe dizer “Hello world” (linhas 17 e 18), já que
dizemos que a relação entre as classes é do tipo “é um”. Essa relação
indica que B é um tipo de A.
Além do tipo simples, em que uma única subclasse herda características da classe-base, temos outros tipos de herança, como a hierárquica
e a multinível (BOOCH et al., 2007). Na hierárquica, mais de uma classe
recebe a herança da mesma classe-base. Em nosso exemplo, podemos
adicionar uma classe C, herdeira de A:
class A {
public void Hello() {
Console.WriteLine("Hello world");
}
}
class B: A {
public void Ola() {
Console.WriteLine("Olá mundo");
}
}

class C: A {
public void Hola() {
Console.WriteLine("Hola mundo");
}
}

44

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Note que a classe A possui o método public Hello (linha 3), que diz

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Já a herança multinível, nos termos do nosso exemplo, acontece
quando B também serve de classe-base para uma classe C. Com isso,
temos que C herda de B, e B herda de A:
class A {
public void Hello() {
Console.WriteLine("Hello world");
}
}
class B: A {
public void Ola() {
Console.WriteLine("Olá mundo");
}
}

class C: B {
public void Hola() {
Console.WriteLine("Hola mundo");
}
}

Em C# não existe herança múltipla, um tipo em que uma subclasse
pode herdar características de duas ou mais classes-base ao mesmo
tempo.
Na herança, as subclasses herdam todos os atributos e métodos da
classe-base, mas não herdam os construtores (estáticos e não estáticos) nem os finalizadores (destrutores). Além disso, os modificadores
de acesso (private, public e protected) afetam essa herança. No nosso
exemplo, se a classe A tiver algum atributo ou método privado, as subclasses dela não os herdarão. Já se o atributo ou método for protected,
somente a primeira subclasse na hierarquia conseguirá herdar, a próxima não. Veja o exemplo a seguir:

Herança e polimorfismo

45

using System;

3

class A {

4

protected void Hello() {

5

Console.WriteLine("Hello world");

6
7

}
}

8
9

class B: A {

10

public void Ola() {

11

Hello();

12

Console.WriteLine("Olá mundo");

13

}

14

}

15

class Programa {

16

static void Main() {

17

A a = new A();

18

B b = new B();

19

b.Ola();

20

//a.hello();

21
22
23

//b.Hello();
}
}

Nesse exemplo, a classe A está com o método Hello (linha 4) como
protected. Assim, somente a própria classe e suas subclasses têm
acesso ao método. Por isso deixamos o comentário no Programa, na
linha 20, pois essa linha produziria um erro de compilação que impede
o acesso a esse método. Na linha 11, porém, conseguimos acesso normalmente, já que a classe B herda de A. Na linha 21 também teremos o
problema da linha 11, já que o método herdado, Hello, é protected.

3 Benefícios de herança
Para exemplificar os benefícios da herança, vamos olhar para o desenvolvimento de jogos na Unity, um motor que permite desenvolver
jogos 2D e 3D. A Unity é uma ferramenta muito visual, que exige menos
46

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

1
2

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

uso de código. Para que a parte do código se integre com a interface
gráfica do ambiente de desenvolvimento, a Unity fornece uma classe-base chamada MonoBehaviour, que passa comportamentos do ciclo
de vida de um jogo para as subclasses:
1
2

using UnityEngine;

3

public class Seguir : MonoBehaviour {

4

public Transform objeto;

5
6

// Update é chamado uma vez para cada frame

7

void Update(){
transform.position = objeto.transform.position +
new Vector3(0, 2, -4);

8
9
10

}
}

Esse script (código em C# para a Unity) possui na linha 4 um atributo,
“objeto”, que é público. Todo atributo público, de uma classe herdeira de
MonoBehaviour, é exibido na interface gráfica da Unity. Para isso, você
precisa atribuir esse código a um objeto do jogo, como, por exemplo, a
câmera. Sim! A câmera é considerada um objeto dentro do jogo, como
os personagens e os itens. Veja a figura 1.
Figura 1 – Interface de programação da Unity

Herança e polimorfismo

47

No nosso código, Transform é uma classe fornecida também pela
Unity e representa a matriz de transformação de um GameObject em
cena. A matriz de transformação permite mudar o posicionamento, o
tamanho e a escala do GameObject nos eixos x, y e z. Por isso, na linha 8
da classe Seguir, nós alteramos a posição da câmera para ser a mesma
posição do atributo objeto, mas acrescentamos um deslocamento de 0
pixels em x, 1 pixel em y e –4 pixels em z, de modo que a câmera fique
atrás do nosso personagem e um pouco acima. Essas posições podem
ser alteradas para obter efeitos diferentes. Além disso, o método da linha 7 é um método herdado da classe-base e no qual implementamos
um novo comportamento. Veremos com mais detalhes esse tipo de
comportamento no próximo subcapítulo. O importante aqui é notar que
não precisamos programar muito para fazer uma ação que é bastante
complexa. O método Update da linha 7, por exemplo, é chamado pela
Unity a cada frame do nosso jogo, e com isso conseguimos o comportamento de seguir o personagem pelo nosso cenário. Se o jogo estiver
rodando a 30 fps (quadros por segundo), o método Update será chamado 30 vezes a cada segundo!
Vale destacar, porém, que a herança não é importante só nesse caso
que abordamos aqui. Segundo Barnes e Kölling (2010), algumas das
vantagens da herança são: evitar código duplicado, reutilizar códigos e
melhorar a manutenção e a extensibilidade.

48

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Nessa figura, temos a hierarquia de objetos no canto esquerdo, e
o Inspector do objeto selecionado, exibindo todos os componentes ligados a esse objeto. Veja que, ao selecionarmos a câmera (item 1 da
figura), o inspetor do objeto exibe os componentes da câmera. O último
desses componentes (item 2) é do tipo script, ao qual vinculamos o código que criamos (a classe Seguir). Ao vincular nosso código, pelo fato
de nossa classe herdar de MonoBehaviour, a Unity adiciona o atributo
objeto à interface, que corresponde ao nosso atributo público. Para que
a câmera siga o personagem, arrastamos seu objeto para nosso atributo público, como indicado no item 3 da figura.

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Evitar duplicação e reutilizar códigos são efeitos relacionados, já que
com a herança, ao adicionarmos um comportamento na classe-base,
todas as subclasses adquirem o mesmo comportamento. Com isso,
não precisamos duplicar o código que representa esses comportamentos, e ao mesmo tempo reutilizamos o código da classe-base. Por consequência, também melhoramos a manutenção, visto que, se o código
reutilizado via herança tiver algum bug, basta corrigi-lo na classe-base, e
todas as classes da hierarquia de herança serão afetadas, evitando a necessidade de corrigir o mesmo problema em vários lugares do código.
A extensibilidade está relacionada à ação de adicionar novas funcionalidades a um sistema já desenvolvido. Com a herança, esse processo
se torna mais simples, já que uma nova versão do sistema pode criar
classes herdeiras de outras já criadas, evitando que precisemos alterar
os códigos existentes. Assim, reduzimos o risco de adicionar falhas a
códigos desenvolvidos anteriormente e já testados.

4 Introdução ao conceito de polimorfismo
Segundo Barnes e Kölling (2010), polimorfismo se refere à capacidade de uma variável conter objetos de diferentes tipos. O termo indica
“várias formas”, a capacidade de algo responder de jeitos diferentes a
uma mesma mensagem. E o conceito não se aplica apenas a variáveis.
Podemos usá-lo em outros contextos.
Vimos anteriormente que em C# as variáveis devem possuir valores
de um único tipo, e as funções devem ter um único tipo de dado como
retorno. Então, como fazer algo ser polimórfico no C#? Como vimos,
na herança, uma subclasse “é um” objeto da classe-base, logo, com a
herança, conseguimos esse comportamento muito útil de adicionar
nas subclasses novos comportamentos e atributos (SCHILDT; SKRIEN,
2013). Para ilustrar esse ponto, vamos partir do exemplo da figura 2.

Herança e polimorfismo

49

Personagem
andar
correr

Mago

Elfo

ataque: básico
ataque: mágico
defesa: mágica

ataque: básico
ataque: arco e flecha
defesa: esquivar

Nesse diagrama está representada a classe Personagem, que possui
dois comportamentos (andar e correr), e duas subclasses dela: Mago e
Elfo. Note que às duas subclasses foram adicionados novos comportamentos: dois tipos de ataques e um tipo de defesa. Para simplificar,
somente dois tipos de personagens foram descritos, mas sabemos que
um jogo pode ter muitos outros. Esses personagens podem compartilhar alguns comportamentos, como andar e correr, mas alguns personagens podem correr de forma diferente, ou ter uma resistência diferente para a corrida. Um elfo, por exemplo, pode correr mais rápido e por
mais tempo que um mago. Logo, deixar o método correr na classe-pai
pode não ser uma boa estratégia.
Imagine uma situação em que há 20 tipos de personagens, e 3 deles
não compartilham a mesma implementação do método correr. Logo,
copiar o método correr da classe-pai nas 20 subclasses trará um problema grande de manutenção. Nesse exemplo, ao usar a mesma implementação em todas as classes, teremos de lembrar de alterar o método correr em 17 classes. Em situações como essa, o polimorfismo nos
será útil.

50

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Figura 2 – Diagrama sobre herança

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

5 Sobrecarga de métodos e substituição
(overriding)
Quando falamos em polimorfismo (permitir que classes tenham
comportamentos diferentes para uma mesma mensagem), nos deparamos com duas técnicas: a sobrecarga e a substituição de métodos.
A sobrecarga de métodos consiste em criar duas ou mais funções
com o mesmo nome e o mesmo tipo de retorno, mas com parâmetros diferentes, de modo a criar um tipo de troca de mensagens que
são diferenciadas pelos parâmetros, e não pelo nome. Já na substituição de métodos, na herança, um método herdado pode ser substituído na subclasse, basta recriá-lo com o mesmo nome, tipo de retorno e
parâmetros.
Vamos começar pela sobrecarga de métodos (ou overloading). No
exemplo da figura 2, o Mago e o Elfo possuem dois tipos de ataques
cada. Usando o Elfo como modelo, podemos criar o seguinte código:
1
2

using System;

3

class Personagem {

4

public void Andar() {

5

Console.WriteLine("Personagem Andando");

6

}

7

public void Correr() {

8

Console.WriteLine("Personagem Correndo");

9
10

}
}

11
12
13

class Elfo: Personagem {
public void Ataque() {

14

Console.WriteLine("Elfo: Ataque Básico");

15

}

16

public void Ataque(int forca) {

Herança e polimorfismo

51

Esse é um exemplo de sobrecarga de métodos. Note que os métodos declarados nas linhas 13 e 16 possuem o mesmo nome e tipo de
retorno, a diferença é que no método da linha 16 há um parâmetro que
representa a força de ataque. Nas linhas 28 e 29, chamamos ambos os
métodos e novamente é possível perceber que usamos o mesmo nome.
Mas na linha 29 passamos o valor 10, o que faz com que cada chamada
seja para um método diferente da classe Elfo.
Para exemplificar a sobreposição de métodos (overriding), usaremos
o código a seguir:
1
2

using System;

3

class Personagem {

4

public int energia = 100;

5
6

public void Correr() {

7

energia = energia - 10;

8
9

}
}

10
11

52

class Elfo: Personagem {

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

		

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

12

public void Correr() {

13

energia = energia - 1;

14
15

}
}

16
17

class Mago: Personagem { }

18
19

class Programa {

20

static void Main() {

21

Elfo e = new Elfo();

22

Mago m = new Mago();

23

e.Correr();

24

m.Correr();

25

Console.WriteLine("Energia do Elfo: " +
e.energia); // 99

26

Console.WriteLine("Energia do Mago: " +
m.energia); // 90

27
28

}
}

Para simplificar, só deixamos os métodos de interesse. Na classe
Personagem, definimos um atributo energia com modificador de acesso público, para facilitar a demonstração (em uma implementação, ele
provavelmente seria protected). O método Correr da linha 6 é a implementação básica do comportamento de correr de qualquer personagem. Dessa forma, classes como Mago, declarada na linha 17, herdam
esse comportamento. Ao correr, um personagem perde 10 de energia.
Por isso, na linha 24, ao correr, o mago perderá 10 de energia e ficará
com 90 no final. Os elfos, porém, são mais resistentes que a maioria dos
personagens, e por isso a classe Elfo sobrescreve o método Correr na linha 12 e fornece uma nova implementação. Nesse novo comportamento, a energia, após uma corrida, é decrementada em apenas 1. Assim, na
linha 23, o elfo ficará com 99 de energia depois de correr.
Na Unity, aplicamos muito essa segunda técnica ao criar um script
para usá-lo em um GameObject. Segundo a documentação da Unity, um
GameObject possui diversos métodos já implementados (UNITY, 2022).
Normalmente, usamos os métodos start e update. O método start é
Herança e polimorfismo

53

é colocado na cena. Já o update é chamado toda vez que um novo frame do jogo é processado. Ou seja, se o seu jogo estiver rodando a 30
frames por segundo, significa que esse método foi chamado 30 vezes
em apenas 1 segundo. Para criarmos nosso personagem, ele deve herdar de MonoBehaviour e, com isso, podemos sobrescrever os métodos
que nos interessam. Veja essa possível implementação para um Elfo:
1
2

using System.Collections;
using System.Collections.Generic;

3

using UnityEngine;

4
5

public class Elfo : MonoBehaviour {

6

int energia = 100;

7
8

void Update() {

9

if (Input.GetKeyDown("d")) {

10

// movimentar personagem

11

energia = energia - 1;

12
13
14

}
}
}

A classe Elfo é subclasse de MonoBehaviour, por isso dizemos que
na linha 8 estamos sobrescrevendo o método Update. Dessa forma, ao
atribuir esse script a um personagem em cena, se pressionarmos a tecla “d” (linha 9), o teste será verdadeiro, e a energia será decrementada
em uma unidade.

Considerações finais
A programação orientada a objetos introduz uma série de novos
conceitos e uma maneira diferente de pensar. Entre esses conceitos,
vimos a herança e o polimorfismo, que caracterizam esse paradigma
de programação.

54

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

chamado pelo motor da Unity toda vez que o objeto que contém o script

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Com a herança, evitamos que os desenvolvedores precisem ter
acesso ao código original e conseguimos adicionar comportamentos
e atributos às classes que já existem no sistema. Isso é o que ocorre,
como vimos, na Unity, que nos fornece a classe MonoBehaviour, com
comportamentos criados pela equipe da própria Unity.
Vimos também o polimorfismo, que nos concede poderes para sobrecarregar métodos em uma classe ou até mesmo sobrescrever métodos herdados, implementando novos comportamentos nas nossas
subclasses.
Considere rever este capítulo e pesquisar outros tipos de mídia sobre
esse assunto. Divirta-se com a orientação a objetos!

Referências
BARNES, David J.; KÖLLING, Michael. Programação orientada a objetos com
Java: uma introdução prática usando o BlueJ. São Paulo: Pearson, 2010.
BOOCH, Grady et al. Object-oriented analysis and design with applications.
Boston: Addison-Wesley, 2007.
FOWLER, Martin. UML essencial: um breve guia para a linguagem-padrão de
modelagem de objetos. Porto Alegre: Bookman, 2005.
SCHILDT, Herbert; SKRIEN, Dale. Programação com Java: uma introdução
abrangente. Porto Alegre: Bookman McGraw Hill, 2013.
UNITY. MonoBehaviour. Unity Documentation, [s. d.]. Disponível em: https://
docs.unity3d.com/ScriptReference/MonoBehaviour.html. Acesso em: 2 nov.
2022.

Herança e polimorfismo

55

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Capítulo 4

Definição de
requisitos

Para desenvolver um bom programa, jogo ou aplicativo, é preciso
um planejamento eficaz. Para isso, é importante entender as exigências que o sistema precisa cumprir (seus recursos, objetivos e utilidades). Chamamos esse planejamento de especificação de requisitos
de software.
57

construir o passo a passo do que ocorrerá a cada ação do usuário. No
decorrer desse capítulo, veremos uma das formas de realizar esse planejamento, com base no acrônimo FURPS+, que representa um modelo
para classificar atributos de qualidade de software (conhecidos como
requisitos funcionais e não funcionais).

1 Introdução a requisitos e suas definições
Processo importantíssimo no desenvolvimento de aplicativos e jogos, o levantamento de requisitos de software consiste em entender
e documentar as necessidades e as expectativas dos usuários finais e
do negócio, para garantir que elas sejam atendidas. É preciso ter cuidado, pois são essas necessidades que devem ser contempladas, e não
a vontade do desenvolvedor, que muitas vezes não é o público-alvo do
produto (VAZQUEZ; SIMÕES, 2016).
O levantamento de requisitos envolve a coleta de informações
sobre o contexto de uso do software, os requisitos funcionais (funcionalidades desejadas) e os requisitos não funcionais (como performance, segurança e usabilidade), as restrições e os requisitos de
implementação (KERR, 2015).
Na arquitetura e na engenharia, é comum vermos plantas de casas
que indicam como deve ser a construção final. Existem diversos tipos
de plantas: umas focam na estrutura, outras focam em instalações elétricas e hidráulicas. Esses documentos são criados e estudados antes de o pessoal da obra começar a construção, porque permitem aos
arquitetos e engenheiros discutir com os proprietários se o que será
construído atende às necessidades. Como se vê na figura 1, a planta
baixa de uma casa pode não apresentar medidas e algumas informações importantes (por exemplo, por quais paredes passam a fiação elétrica e o sistema hidráulico), mas temos noção dos espaços utilizados
para cada cômodo.
58

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Nessa etapa, de especificação de requisitos de software, devemos

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Figura 1 – Planta baixa de uma casa

Na área de software não é diferente. Antes do desenvolvimento, precisamos levantar os requisitos. Mesmo para um software mais simples,
sem tantos detalhes, é recomendado que esse processo seja feito. As
informações podem ser reunidas por meio de entrevistas, documentos
e protótipos, entre outras técnicas.
O documento chamado “Especificação de requisitos” serve como
base para o projeto do software e para o gerenciamento do projeto. Ele
é utilizado por todos os envolvidos no desenvolvimento, desde a área de
negócio até a área de teste.
Essa é uma etapa crítica no desenvolvimento de software, pois um
levantamento de requisitos mal feito pode levar a problemas como
atrasos no projeto, aumento de custos e insatisfação dos usuários.
Imagine desenvolver um excelente sistema, o mais eficiente possível,
mas diferente do que o usuário precisa. Segundo Vazquez e Simões
(2016), 47% dos projetos (software e outros tipos de projetos) não são

Definição de requisitos

59

ou não cumprem essa etapa do desenvolvimento.
Neste capítulo iniciaremos os estudos sobre levantamento de requisitos para construir um documento de “Especificação de requisitos”
com base no FURPS+.

2 Apresentação dos requisitos FURPS+
Para desenvolver produtos que atendem às expectativas das pes­
soas, é muito importante ter atenção a requisitos essenciais que diminuem o risco de insucesso. Existem diversas práticas e ferramentas para nos ajudar a definir esses requisitos e características de um
software. O modelo FURPS+ é uma delas.
Criado por Robert Grady, FURPS é um acrônimo para functionality, us­
ability, reliability, performance e supportability (funcionalidade, usabilidade, confiabilidade, desempenho e suportabilidade).
Mais tarde, Peter Eeles (2005) propôs o FURPS+, que acrescenta ao
FURPS quatro novas categorias de requisitos não funcionais. Mas antes
de falar dessas quatro categorias, vamos entender mais sobre cada um
dos requerimentos comuns ao modelo FURPS e FURPS+.
• Funcionalidade: nesta categoria descrevemos o que o nosso sistema/jogo/app deve fazer (os requisitos funcionais).
• Usabilidade: nesta categoria descrevemos requisitos relacionados
à interação dos usuários com o sistema. Esses requisitos buscam
padronizar e dar consistência a formas de uso, à documentação e
ao design do sistema, bem como prevenir usos incorretos.
• Confiabilidade: nesta categoria definimos quão confiável um sistema precisa ser, estabelecendo a frequência de falhas aceitáveis,
as formas de recuperação do sistema e o tempo médio entre

60

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

bem-sucedidos porque falham na fase de levantamento de requisitos

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

falhas (MTBF). Nenhum sistema é 100% confiável, mas alguns
precisam ser mais confiáveis que outros. Imagine, por exemplo,
ter pouca confiança em um sistema que controla um robô usado
em cirurgias.
• Desempenho: assim como ocorre com a confiabilidade, alguns
sistemas/jogos/aplicativos necessitam de maior desempenho.
Por isso, esta categoria define a limitação de tempo de resposta, a
memória máxima utilizada, a quantidade máxima de usuário simultâneos, a carga máxima suportada e a disponibilidade.
• Suportabilidade: esta categoria agrupa uma série de subcategorias,
como facilidade de realizar testes (testabilidade) e facilidade de realizar manutenções no sistema (manutenibilidade), entre outras.
As quatro categorias acrescentadas no modelo FURPS+ se referem
a requisitos de design, de implementação, de interface e físicos, descritos a seguir.
• Design: requisitos que descrevem restrições de interface, cores,
fontes, etc. Questões como acessibilidade para pessoas daltônicas entram nesta categoria.
• Implementação: esta categoria define qual linguagem pode ser
usada e o ambiente de desenvolvimento, entre outros requisitos
que definem como a implementação deve ser feita.
• Interface: o termo interface, nesse contexto, refere-se à comunicação com sistemas externos (ao formato dos dados trocados
entre o sistema interno e externo, ao tempo de resposta das
ações, etc.).
• Físicos: esses requisitos se referem a limitações como peso, tamanho e outros fatores físicos. Embora tais fatores sejam um
pouco estranhos para um software, aqui definimos os requisitos
mínimos de hardware para desenvolver ou produzir o sistema.

Definição de requisitos

61

guimos mensurar riscos, tempo de desenvolvimento, estrutura e dificuldades envolvidas. O modelo FURPS+ deve ser associado ao ambiente
de desenvolvimento para auxiliar a tomada de decisões, guiando as escolhas de forma que as restrições do projeto sejam compatíveis com o
valor de negócio esperado pelo cliente.
Agora, vamos pensar juntos: usando o modelo FURPS+, como seria
um levantamento de requisitos de um jogo básico? No primeiro momento, nosso cliente só informou o seguinte enredo: “Um herói com
poderes não descobertos tem sua amada, a princesa Catarina, levada
de seu castelo por um vilão de um reino distante. Obcecado, o herói
parte, acompanhado de seu fiel escudeiro, para resgatar a princesa”.
É possível construir um jogo completo com essas informações?
A resposta é não, pois cada um dos envolvidos no desenvolvimento terá
ideias diferentes para cada parte do jogo, visto que o enredo apresentado é muito simples. Então, quais requisitos poderiam ser levantados
para nos ajudar a entender melhor como fazer esse jogo?
Veja a seguir um exemplo de levantamento de requisitos utilizando
o FURPS+. Esse exemplo não é exaustivo; muitos outros requisitos são
necessários para orientar melhor o desenvolvimento de um jogo. Mas
o objetivo aqui é ajudar a entender o modelo FURPS+. O quadro 1 apresenta alguns requisitos classificados como funcionais no FURPS+.
Quadro 1 – Requisitos funcionais (funcionalidades)

62

REQUISITO

DESCRIÇÃO

Cenário

O mapa será gerado de forma aleatória e procedural.

Plataforma

O jogo será em plataforma 2D.

Condição de vitória

O jogador ganha o jogo quando derrotar o vilão mais poderoso.

Vida

A vida do herói é composta por 3 corações com 100 pontos de vida.

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

A partir do conhecimento obtido com os requisitos listados, conse-

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Note que os requisitos do quadro 1 se referem a pontos específicos de como o jogo deve funcionar. Nas funcionalidades, descrevemos requisitos mais tradicionais, associados às características principais do sistema.
Os pontos do quadro 1 esclarecem um pouco mais como o jogo deve
ser, mas são insuficientes para compreender todo o projeto – e não só
porque ainda falta entender os requisitos não funcionais, mas também
porque apenas quatro requisitos foram descritos.
O quadro 2 exemplifica o primeiro conjunto de requisitos não funcionais, ligados à usabilidade, que se referem a aspectos de interação entre
usuário e sistema.
Quadro 2 – Requisitos não funcionais (usabilidade)
REQUISITO

DESCRIÇÃO

Interface

O jogo deverá ter interface moderna.

Interface

A qualquer momento o jogador terá um menu de opções à sua disposição.

Observe os requisitos descritos no quadro 2: o primeiro é subjetivo, pois permite múltiplas interpretações e pode confundir as pessoas
envolvidas no desenvolvimento do jogo, enquanto o segundo, embora
não descreva o que o menu terá, deixa claro que esse menu deve estar
disponível a qualquer momento do jogo. Fique atento ao escrever a descrição dos requisitos, porque requisitos subjetivos são inconsistentes e
dificultam o entendimento do problema. Procure descrever todo requisito de forma objetiva.
A seguir, no quadro 3, são apresentados os requisitos de confiabilidade, que definem o quão confiável nosso sistema/jogo deve ser.

Definição de requisitos

63

REQUISITO

DESCRIÇÃO

Disponibilidade do sistema

Em caso de perda de conexão online, o jogo deverá continuar buscando

(conexão offline)

conexão em segundo plano.

Falha

Em caso de falha ou travamento, o jogo deverá reiniciar e gerar um feedback
ao jogador.

No quadro 4, são descritos os requisitos de desempenho, relacionados à velocidade de resposta de um ou mais serviços. Nesse caso, relacionamos uma situação em que, se o requisito de desempenho não for
alcançado, o sistema e a experiência do usuário serão comprometidas.
Quadro 4 – Requisitos não funcionais (desempenho)
REQUISITO

DESCRIÇÃO

Carga e tempo

O jogo deverá suportar no mínimo 100 jogadores conectados simultaneamente no

de resposta

horário de pico e com tempo de resposta em no máximo 500 milissegundos.

Os requisitos de suportabilidade são apresentados no quadro 5. Esse
conjunto de requisitos agrupa uma série de subcategorias, que não estão necessariamente ligadas umas às outras. Essas subcategorias são:
testabilidade, adaptabilidade, configurabilidade e manutenibilidade.
Quadro 5 – Requisitos não funcionais (suportabilidade)
REQUISITO

DESCRIÇÃO

Testabilidade

As telas do jogo devem suportar automação de testes de interface.

Adaptabilidade

O jogo deve ser capaz de adaptar sua interface a diversas resoluções de tela.

Configurabilidade

Manutenibilidade

64

Em qualquer momento o jogador poderá alterar configurações para melhor
atendê-lo.
O jogo criará um backup em nuvem do progresso do jogador em um intervalo
de tempo fixo.

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Quadro 3 – Requisitos não funcionais (confiabilidade)

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Com a descrição de requisitos dos quadros de 1 a 5, fechamos o
conjunto do FURPS, mas ainda falta o +. Nos quadros de 6 a 9, descrevemos exemplos de outros grupos de requisitos não funcionais.
No quadro 6, temos os requisitos de design. Como o nome sugere,
esses requisitos estão ligados a questões de interface e usabilidade,
abordando temas como tipografia, cores, posicionamento, formas de
interação e acessibilidade.
Quadro 6 – Requisitos não funcionais (design)
REQUISITO

DESCRIÇÃO

Cores

As cores usadas devem possibilitar que pessoas daltônicas joguem sem dificuldade.

Acessibilidade

Na configuração principal deve haver opção de legenda e narração para pessoas
surdas e pessoas cegas ou com baixa visão.

Dois exemplos de requisitos não funcionais ligados aos requisitos de
implementação são apresentados no quadro 7. Esses requisitos orientam os desenvolvedores e arquitetos de software que de fato implementarão a solução.
Quadro 7 – Requisitos não funcionais (implementação)
REQUISITO

DESCRIÇÃO

Motor do jogo

Todo o jogo deve ser desenvolvido utilizando a Unity 3D.

Linguagem de programação

A linguagem usada na Unity 3D deve ser C#.

No quadro 8 são apresentados dois exemplos de requisitos não
funcionais de interface. Esses requisitos, como se pode notar nos
exemplos, referem-se à performance de comunicação entre o jogo e o
servidor, e até mesmo ao formato dos dados que serão comunicados
entre as partes.

Definição de requisitos

65

REQUISITO

DESCRIÇÃO
No modo single player, o tempo de resposta do servidor pode ser de até 1.000

Tempo de

milissegundos, mas no modo multiplayer o tempo não deve ultrapassar os 300

resposta

milissegundos.

Formato dos
dados

Todas as mensagens entre o servidor e o jogo devem ser feitas utilizando o formato JSON.

O quadro 9 apresenta requisitos físicos, que se referem a limitações
como peso, tamanho e outros fatores físicos. Esses requisitos parecem
um pouco estranhos para um software, mas por meio deles podemos definir qual o hardware necessário para ser usado no desenvolvimento do jogo.
Quadro 9 – Requisitos não funcionais (requisitos físicos)
REQUISITO

DESCRIÇÃO

Placa gráfica

normalmente utilizando as placas de vídeo integradas à placa-mãe, sem prejuízo à

Deve-se permitir que jogadores sem placa gráfica dedicada consigam jogar
experiência do jogo.

Memória

O jogo não pode exigir computadores com mais do que 8 GB de memória para funcionar
normalmente em sua resolução média.

NA PRÁTICA
Quanto mais requisitos, mais assertivo será o desenvolvimento do jogo.
Algumas perguntas ainda estão sem respostas, como: quais serão as
regras de entrada e saída desse jogo? Como a história do jogo vai se
desenvolver e quando terminará?
Faça um exercício colocando outros requisitos nos quadros apresentados do FURPS+.

Como dito anteriormente, os quadros apresentados neste capítulo não pretendem ser exaustivos. Trata-se apenas de uma relação de
66

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Quadro 8 – Requisitos não funcionais (interface)

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

requisitos para explicar cada parte do FURPS+. Mas também é necessário lembrar que projetos pequenos não precisam ter requisitos muito
detalhados. Maiores detalhamentos são necessários conforme mais
pessoas participam do processo de desenvolvimento, quando, além
dos desenvolvedores, incluímos outras áreas, como a área de negócio e
equipes de design e teste. Nesse caso, pormenorizar os requisitos ajuda
a reduzir ruídos na comunicação entre as equipes.

Considerações finais
Quando te pedem para desenvolver algo, qual o seu processo para
entender o que fazer? Faça perguntas, anote as respostas. Com base
nas suas anotações, use um método para registrar os requisitos funcionais e não funcionais. Não tenha vergonha se perceber que ainda há
perguntas a fazer e, se for esse o caso, volte e faça essas perguntas,
pois a falta de informação pode levar seu projeto ao fracasso. O modelo FURPS+, como vimos, pode te orientar nesse processo de registrar
os requisitos, servindo como um checklist para suas entrevistas com os
envolvidos no projeto.

Referências
EELES, Peter. Appendix A: Analysis Mechanisms. IBM, 30 abr. 2004. Disponível
em: https://web.archive.org/web/20160316212610/http://www.ibm.com/
developerworks/rational/library/4707.html. Acesso em: 10 dez. 2022.
GRADY, Robert; CASWELL, Deborah. Software metrics: establishing a company-wide program. Englewood Cliffs: Prentice-Hall, 1987.
KERR, Eduardo Santos (org.). Gerenciamento de requisitos. São Paulo: Pearson,
2015.
VAZQUEZ, Carlos Eduardo; SIMÕES, Guilherme Siqueira. Engenharia de requisitos: software orientado ao negócio. Rio de Janeiro: Brasport, 2016.

Definição de requisitos

67

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Capítulo 5

Introdução a
casos de uso

Neste capítulo trataremos dos primeiros passos da modelagem de
um sistema tomando como base a Unified Modeling Language (UML),
uma notação gráfica que nos permite descrever visualmente um sistema e o problema que ele pretende resolver.
Criada por volta de 1997, a UML tem como proposta padronizar o processo de especificação e modelagem de sistemas que utilizam o paradigma da programação orientada a objetos. Em sua segunda versão, a
UML descreve treze tipos de diagramas, divididos em dois grandes grupos: os diagramas de estrutura e os de comportamento.
69

O diagrama de casos de uso é uma ferramenta que nos ajuda a documentar os requisitos do sistema, mas apenas os funcionais, diferentemente do FURPS+, que descreve requisitos funcionais e não funcionais. Esse tipo de documentação traz uma visão externa do sistema, e
não os detalhes de implementação.
Uma vez que deve vir acompanhado de um texto, o diagrama de
classes acaba sendo um resumo do que está descrito. Por isso Fowler
(2005) recomenda que gastemos mais tempo com o texto do que com
o diagrama. Ainda assim, é importante ressaltar que o diagrama pode
ser uma ótima ferramenta para que a pessoa responsável pelo levantamento dos requisitos converse com clientes, que muitas vezes não são
especialistas.

1 Introdução a atores
No diagrama de casos de uso, começamos pensando em quais são
os atores, ou seja, os usuários que fazem parte do processo em que o
sistema está incluso. Os atores podem ser classificados em primários
e secundários. Se um ator descrito no sistema interage com o software,
ele é um ator primário. Se é um ator que interage com outro usuário, e
não com o software, ele é secundário.
A UML especifica que a notação para ator é um “homem palito”, e
seu papel (a função que ele exerce no sistema) deve ser descrito logo
abaixo. Uma pessoa pode ter mais de um papel em um sistema, mas,
para o diagrama, caso os papéis tenham funções distintas, devemos
descrever cada um deles separadamente. A figura 1 apresenta alguns
exemplos de atores em um diagrama de casos de uso.
70

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Aqui trataremos do diagrama de casos de uso, do grupo de diagramas de comportamento. Esse diagrama tem como objetivo descrever
como os usuários interagem com o sistema e como usuários secundários (que podem não interagir com o sistema) se relacionam com outros
usuários.

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Figura 1 – Exemplos de atores no diagrama de casos de uso

Aluno

Jogador

Gerente
do Banco

Sistema
de IA

Percebe-se que um dos atores do diagrama, o sistema de IA (inteligência artificial), não é uma pessoa. Um ator pode ser um subsistema
ou até mesmo um sistema externo. Ele não precisa ser necessariamente uma pessoa.

2 Introdução a cenários
Na definição dos casos de uso, os cenários estão diretamente ligados aos requisitos funcionais do nosso sistema. Um cenário pode agrupar mais de um requisito funcional.
Ao definirmos um cenário é importante incluir detalhes sobre ele,
como nome (caso de uso), atores envolvidos, precondições, pós-condições, fluxo principal e fluxo alternativo. Como dito por Fowler (2005),
devemos focar nossos esforços no texto e usar o diagrama como um
resumo.
O nome de um cenário é definido pelo caso de uso que classifica o
comportamento completo de uma funcionalidade do sistema. O caso
de uso pode ser executado por um ou mais atores, que devem aparecer
no documento textual.
A precondição de um cenário descreve em que condições os atores
e o sistema devem se encontrar. Por exemplo, em um jogo multiplayer,
para que um jogador possa entrar em uma partida competitiva, pode-se

Introdução a casos de uso

71

soma de tempo de jogo superior a dez horas.
A pós-condição define qual o estado do sistema após a execução de
todo o cenário. Utilizando o mesmo exemplo, se estamos falando de um
caso de uso “entrar em uma partida competitiva online”, a pós-condição
poderia ser: “o jogador está em uma das duas equipes de uma sala de
espera para início de partida competitiva”.
O fluxo principal é uma descrição passo a passo do que esse caso de
uso deve executar para chegar à pós-condição, e que podemos chamar
de caminho-padrão.
O fluxo alternativo, diferentemente do principal, não é o caminho-padrão, mas, por exemplo, as alternativas que o usuário tem ao solicitar
para entrar em uma partida competitiva online. O fluxo normal leva o
usu­ário a uma sala com jogadores do mesmo país e com jogadores de
nível próximo. Em um fluxo alternativo, o jogador pode escolher entrar
em um servidor que não fica na sua região, ou escolher jogar com jogadores profissionais, mesmo sendo um jogador iniciante. O fluxo alternativo também leva o ator à pós-condição do caso de uso, mas por um
caminho diferente.
O quadro 1 descreve um cenário em que o ator Jogador deseja iniciar
uma partida online.
Quadro 1 – Exemplo de cenário de caso de uso
CENÁRIO

Iniciar partida online

ATORES

Jogador

PRECONDIÇÃO

Jogo atualizado. Conta e senhas validadas.
1. Jogador escolhe entrar na partida online.

FLUXO PRINCIPAL

2. Jogador não escolhe nenhuma opção de personalização.
3. Mostra estado da busca.
4. Mostra a sala de espera da partida encontrada.
(cont.)

72

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

exigir que ele esteja autenticado no jogo, e que sua conta tenha uma

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

1. Jogador escolhe entrar na partida online.
2. Jogador escolhe opção de servidores estrangeiros.
FLUXO ALTERNATIVO

3. Mostra mensagem informando que o usuário pode ter problema com latência
durante o jogo.
4. Jogador confirma a escolha e mostra estado da busca.
5. Mostra a sala de espera da partida encontrada.
1. O sistema indica que o usuário não está autenticado.

FLUXO DE EXCEÇÃO 1

2. O sistema informa o erro.
3. O jogador é redirecionado para a página de login.
1. O sistema identifica que não existe conexão com a internet.

FLUXO DE EXCEÇÃO 2

2. O sistema indica o erro e solicita ao usuário corrigi-lo antes de seguir.
3. O jogador é redirecionado para a tela inicial do jogo.

PÓS-CONDIÇÃO

Jogador encontra-se em uma sala de espera com outros jogadores, aguardando o
início da partida.

O quadro 2 descreve um cenário no qual o mesmo ator, Jogador,
pode alterar o volume do jogo.
Quadro 2 – Exemplo de cenário de caso de uso (alterar volume do jogo)
CENÁRIO

Alterar volume do jogo

ATORES

Jogador

PRECONDIÇÃO

Jogo atualizado
1. Jogador entra nas configurações de áudio.

FLUXO PRINCIPAL

2. Jogador muda o controle de volume.
3. Jogador confirma a alteração.
4. Volume do jogo é alterado.

FLUXO ALTERNATIVO
PÓS-CONDIÇÃO

Nenhum
O jogo está com o novo volume configurado.

Note que, diferentemente do exemplo do quadro 1, neste cenário do
quadro 2 o fluxo alternativo não existe. Isso demonstra que o usuário
não tem opção de caminhos diferentes para seguir.

Introdução a casos de uso

73

Será que precisamos de tudo o que vimos até aqui só para desenvolver um aplicativo ou um jogo? Existem projetos grandes, médios e
pequenos. É difícil determinar com certeza quando um projeto deixa de
ser pequeno e se torna médio, mas, em todos os casos, precisamos de
um bom levantamento de requisitos e outros níveis de modelagem, variando apenas em grau. Com certeza não precisamos de todos os treze
diagramas da segunda versão da UML para desenvolver uma aplicação
pequena, e talvez mesmo uma aplicação grande.
Segundo Fowler (2005, p. 12), “um bom diagrama frequentemente
pode ajudar a transmitir ideias sobre um projeto, particularmente quando você quer evitar muitos detalhes”. Sobretudo quando trabalhamos
em equipe, fazer que todos tenham o mesmo entendimento sobre o
projeto não é uma tarefa fácil, e os diagramas podem ajudar.
Rangel e Carvalho Jr. (2021) comentam que o levantamento de requisitos é uma fase muito importante do desenvolvimento de software, mas necessitamos também de mais informações que nos mostrem
como cada usuário vai interagir com o sistema. Por isso, os autores
sugerem o diagrama de casos de uso como um primeiro passo.

PARA SABER MAIS
Se você deseja se aprofundar no diagrama de casos de uso, leia o livro
Sistemas orientados a objetos: teoria e prática com UML e Java, de Rangel
e Carvalho Jr. (2021). O capítulo 2 apresenta conceitos iniciais de modelagem, e especificamente na seção 2.4 há detalhes sobre o diagrama de
casos de uso.

74

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

3 Introdução a diagramas

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

O diagrama de casos de uso descreve graficamente, de forma resumida, como os atores do sistema interagem com cada uma das funcionalidades. Discutir esse diagrama ou outros diagramas iniciais com
a equipe – e principalmente com o cliente – é fundamental para evitar
entendimentos equivocados sobre o produto. A figura 2, muito conhecida na área da computação, expressa claramente os problemas que
podemos ter do levantamento de requisitos até o desenvolvimento do
produto final.
Figura 2 – Problemas de comunicação no desenvolvimento de software

Como o cliente
explicou.

Como o líder do projeto
entendeu.

Como o analista
desenhou.

Como o programador
desenvolveu.

Como os beta testers
receberam.

Como o consultor de
negócios descreveu.

Como o projeto
foi documentado.

O que os técnicos
instalaram.

Como faturaram para
o cliente.

Como foi o suporte
técnico.

Como o marketing
publicou.

O que o cliente
realmente precisava.

Fonte: adaptado de Project Cartoon (2006).

Introdução a casos de uso

75

necessidade, e a última mostra o que ele realmente necessitava. No simples passo de explicar a outro o que se deseja pode ocorrer um problema
de comunicação. Para reduzir esse impacto, utilizamos os diagramas,
que, por serem visuais e até certo ponto intuitivos, permitem que o desenvolvedor converse com o cliente sobre o que será feito.
Anteriormente vimos os casos de uso na forma de texto; a figura 3
apresenta um diagrama.
Figura 3 – Exemplo de diagrama de casos de uso

Ator

Jogo multiplayer

Iniciar
partida local

Valida
requisitos para
partida online

<<include>>
Jogador

Iniciar
partida online

Incluir novo
item de personagem
na loja

Comprar item
para o personagem

Caso
de uso

Funcionário
Apagar item
de personagem
da loja

Inclusão
Limite do
sistema

76

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Na figura 2, a primeira ilustração mostra como o cliente explicou sua

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

No diagrama da figura 3, temos dois atores: Jogador e Funcionário.
O ator Jogador pode:
1. Iniciar partida local.
2. Iniciar partida online, o que inclui o caso de uso de validar requisitos para partida online.
3. Comprar item para o personagem.
Veja que somente essas informações não nos dão detalhes de como
cada caso de uso funciona, mas já são um bom resumo para verificarmos se o ator Jogador pode realmente realizar essas ações no sistema.
O ator Funcionário pode:
1. Incluir novo item de personagem na loja.
2. Apagar item de personagem da loja.
Todos os usos descritos estão dentro de um retângulo maior que
define o limite do sistema, visto que é possível criar sistemas diferentes
em um mesmo diagrama, além de podermos definir casos de uso que
não fazem parte do sistema.

Considerações finais
Levantamento de requisitos e diagrama de casos de uso se complementam. Levantamos requisitos por meio de entrevistas com o nosso
cliente, mas só isso é insuficiente para entendermos como cada um
dos atores interagirá com o sistema. Para suprir essa necessidade, criamos um diagrama que nos permite descrever visualmente os casos de
uso – reunindo um ou mais requisitos funcionais – e, assim, ter um
documento que facilite a conversa com o cliente. Todos os sistemas, independentemente do tamanho, precisam de uma boa modelagem, que
deve ser detalhada para evitar problemas de comunicação.

Introdução a casos de uso

77

cisa gastar muita energia incluindo nele todos os detalhes. O texto que
descreve cada cenário do sistema é que precisa ser mais completo,
pois ele orientará os desenvolvedores ao trazer informações como fluxo
principal, fluxos alternativos e até fluxos de exceção.

Referências
FOWLER, Martin. UML essencial: um breve guia para a linguagem-padrão de
modelagem de objetos. Porto Alegre: Bookman, 2005.
PROJECT CARTOON. How IT projects really work (version 1.5) –
Portuguese. Project Cartoon, 2006. Disponível em: https://web.archive.
org/web/20061117011217/http://www.projectcartoon.com/cartoon/33.
Acesso em: 15 fev. 2023.
RANGEL, Pablo; CARVALHO JR., José Gomes de. Sistemas orientados a objetos: teoria e prática com UML e Java. Rio de Janeiro: Brasport, 2021.

78

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Ao criar um diagrama de casos de uso, lembre-se que você não pre-

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Capítulo 6

Modelagem
conceitual

Neste capítulo abordaremos o tema da modelagem conceitual, utilizando como base a UML. Outras abordagens e diagramas podem ser
usados na área de modelagem conceitual. Mas, independentemente
dessa variedade, deve-se ter em mente a importância dessa etapa, que
contribui com o levantamento de requisitos, nos ajudando a entender
melhor o domínio em que um problema está inserido.
Usaremos uma simplificação do diagrama de classes da UML para
identificar as entidades que fazem parte do problema e seus relacionamentos. Por enquanto, não entraremos nos detalhes da modelagem de
classes com UML.
Para entender os primeiros passos, veremos uma situação-problema em que analisamos os requisitos de nosso jogo para elaborar um
simples diagrama de casos de uso e, depois, construirmos nosso primeiro diagrama conceitual.
79

Assim como para construir uma casa é preciso ter boas plantas, o
desenvolvimento de um software/jogo exige um bom planejamento,
com documentos que nos ajudem a compreender o que deve ser feito.
Segundo Barnes e Kölling (2010), as primeiras etapas do desenvolvimento de um software incluem a análise e o design da solução. Os autores observam que os primeiros passos do design estão em um nível de abstração mais alto, ou seja, ainda longe das classes que nosso software terá.
A modelagem conceitual está muito distante da implementação,
mas nos ajuda a criar um vocabulário para o domínio a que o nosso problema pertence (FOWLER, 2005). Vamos explicar na prática. Considere
o seguinte texto, construído a partir de entrevistas com um cliente que
deseja desenvolver um jogo. Em itálico estão anotados palavras e frases que podem nos ajudar a construir nossos modelos:
“Construir um jogo que permita ao jogador criar diversos mundos. Os
mundos possuem nome e são do tipo aberto. Além disso, cada mundo
possui um único tipo de clima e um único tipo de terreno. Os climas
disponíveis são: chuvoso, ensolarado e neblinoso. Já os tipos de terreno
são: selva, deserto ou campo. Em cada um desses mundos o jogador
consegue criar um personagem, que deve ter um nome e um tipo (elfo,
duende, humano ou orc). Ao navegar pelo mundo, o jogador consegue
capturar animais selvagens e domesticá-los. O animal domesticado passa a ser amigo do personagem e o segue em sua missão de exploração. Um personagem pode ter vários animais, mas um animal será fiel
a um único personagem. Os animais são identificados por sua espécie
e por um apelido, que é dado pelo personagem. O objetivo geral do jogo
é conhecer diversas espécies de animais. As espécies de animais serão
geradas automaticamente, levando em conta o clima e o tipo de terreno
de cada mundo. O tipo de personagem também influencia se será mais
ou menos difícil domesticar um animal, a depender também do clima e
do terreno do mundo.”
80

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

1 Introdução à modelagem conceitual

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Levando em conta as ações de um jogador e do próprio jogo, um
possível diagrama de casos de uso é o apresentado na figura 1.
Figura 1 – Diagrama de casos de uso

Dar nome
ao mundo
<<includes>>

Criar mundo

<<includes>>

Escolher clima
e terreno

<<includes>>

Escolher
mundo

Criar
personagem

<<includes>>

Escolher tipo
de personagem

<<includes>>

Explorar
mundo

Jogador

Criar animais

Domesticar
animais

Nesse diagrama da figura 1, o único ator (jogador) consegue criar,
escolher e explorar um mundo e domesticar animais. Criar um mundo
inclui lhe dar nome, escolher seu clima e terreno e criar os animais que
existirão nele. Além disso, ao criar um mundo o jogador deve criar o personagem para esse mundo, o que inclui escolher o tipo do personagem.
Com o diagrama de casos de uso, conseguimos ilustrar as ações do
nosso único ator, mas não temos muitas informações sobre quais elementos pertencem ao jogo. Por exemplo, o diagrama não indica que o
personagem deve ter um atributo nome, e só inferimos que ele tem um
tipo por causa da ação “escolher tipo”. Para entender melhor o domínio
do problema, usaremos uma simplificação do diagrama de classes a
fim de gerar um modelo conceitual, conforme a figura 2.

Modelagem conceitual

81

Terreno

Clima

<<id>> id: Integer
tipo: String

<<id>> id: Integer
tipo: String

1
(a)

1
tem

tem

(b)
(e)

Personagem
<<id>> id: Integer
nome: String
tipo: String

(c)

(f)

*

*
(d)

Mundo
1

pertence

*

<<id>> id: Integer
nome: String

1

1
pertence

cria

*

*
Animal

<<id>> id: Integer
apelido: String
especie: String

No modelo de domínio da figura conseguimos representar as entidades que fazem parte do nosso negócio. Note que temos os itens de a a
f, que são:
a. Os retângulos representam as entidades e agrupam um nome e
seus atributos.
b. Nome da entidade (um substantivo que representa algo dentro
do nosso jogo). Nesse diagrama temos Personagem, Animal,
Mundo, Terreno e Clima, os substantivos que identificamos no
texto. Mas cuidado, porque nem todo substantivo será uma entidade. Essa é uma fase de análise, então busque sentido em cada
uma das entidades.

82

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Figura 2 – Modelo conceitual usando UML (modelo de domínio)

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

c. Os atributos das nossas entidades. Nesse caso, o Personagem
tem somente nome e tipo. Poderíamos colocar o nome como
nosso <<id>>, mas uma entidade precisa ter um identificador
único. Por isso criamos um identificador artificial, que será um
número inteiro.
d. As linhas que ligam as entidades representam um relacionamento. Nesse caso o texto nos diz que um jogador cria um personagem para cada mundo.
e. Cada relacionamento deve ser rotulado. Nesse caso o rótulo diz
“pertence”, pois um personagem pertence a um mundo, ou seja,
ele está ligado diretamente com esse mundo.
f. Nas extremidades das linhas que ligam as entidades, indicamos
a multiplicidade, que pode ser “*” (asterisco que significa “muitos”), “0..*” (zero ou muitos), “0..1” (zero ou um) e “1” (um). Nesse
exemplo, na ligação entre Personagem e Mundo, devemos ler as
multiplicidades da seguinte forma: “Um personagem pertence a
um único Mundo, e um Mundo pode ter muitos Personagens”.
Com base no que foi explicado, verifique se as outras ligações fazem
sentido, comparando o diagrama com o texto construído a partir das
entrevistas com o cliente. Note que agora temos mais informações sobre nosso domínio e definimos um vocabulário mais rigoroso para ele.
Temos termos como Personagem, Mundo, Clima, Terreno e Animal, que
definem as entidades, e outros como “pertence”, “cria”, etc., que definem
os relacionamentos.

IMPORTANTE
Lembre-se: o diagrama de casos de uso representa o comportamento
do nosso sistema, ou seja, as ações dos atores. O modelo de domínio
representa como os dados são estruturados, como eles se relacionam.
Logo, não compare diretamente um diagrama com o outro. Eles têm

Modelagem conceitual

83

perspectivas diversas.

Um modelo de domínio é um bom ponto de partida para construir as
classes. Além disso, ele é independente de paradigmas e tecnologias, isto
é, não precisamos necessariamente ir à programação orientada a objetos
para construir um software com base nesse modelo, tampouco ele precisa
ser implementado em C#. O objetivo do modelo é orientar todos da equipe
sobre como as informações estão estruturadas, ligadas, relacionadas.
A partir do modelo de domínio da figura 2, podemos construir um diagrama de objetos para representar exemplos de instância das entidades
e verificar se nossa modelagem faz sentido. A figura 3 apresenta um primeiro diagrama de objetos com apenas um personagem e um mundo.
Figura 3 – Exemplo de diagrama de objeto

: Clima

: Terreno

<<id>> id: 1
tipo: chuvoso

: Personagem
<<id>> id: 1
nome: Astroldo
tipo: humano

<<id>> id: 3
tipo: campo

: Mundo
<<id>> id: 1
nome: Terra Média

: Animal
<<id>> id: 1
apelido: Twitter
especie: canário

: Animal
<<id>> id: 2
apelido: Felix
especie: leão

84

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

propósitos diferentes e nos ajudam a olhar para o mesmo software por

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Na figura 3, temos todas as entidades com valores atribuídos. O nome
de cada entidade é precedido de dois-pontos, indicando que se trata de
uma instância da entidade, e não de sua definição. Nesse exemplo, o personagem Astroldo pertence ao mundo Terra Média, que tem clima “chuvoso” e terreno “campo”. Nesse mundo, temos somente dois animais:
Twitter e Felix, que já foram domesticados por Astroldo – isso pode ser
afirmado porque o Animal tem duas ligações, a primeira com Mundo, indicando pertencimento a esse mundo, e outra com o Personagem.
Na figura 4, incluímos mais um personagem, em um mundo diferente.
Figura 4 – Exemplo de diagrama de objeto

: Clima
<<id>> id: 1
tipo: chuvoso

: Personagem

: Terreno
<<id>> id: 3
tipo: campo

: Mundo

<<id>> id: 1
nome: Astroldo
tipo: humano

<<id>> id: 1
nome: Terra Média

: Animal
<<id>> id: 1
apelido: Twitter
especie: canário

: Animal
<<id>> id: 2
apelido: Felix
especie: leão

: Clima
<<id>> id: 2
tipo: ensolarado

: Personagem
<<id>> id: 2
nome: Kramula
tipo: Ork

: Mundo
<<id>> id: 2
nome: Lugar Nenhum

: Animal
<<id>> id: 4
apelido: Dogin
especie: cachorro

: Animal
<<id>> id: 3
apelido: Snake
especie: cobra

Modelagem conceitual

85

Considerações finais
Na construção civil, se desejamos ter uma boa casa, além de seguir
normas, precisamos de planejamento. Não basta que todas as informações estejam na cabeça do engenheiro, pois vários outros prestadores de serviço executarão a obra. Por isso, plantas são desenhadas.
Do mesmo modo, desenvolver um software não se limita a criar códigos. Precisamos de alguns documentos, mesmo que simples, para
nos orientar.
Um bom levantamento de requisitos nos permite saber o que nosso
sistema deve fazer e quais são as restrições impostas a ele. Já o diagrama de casos de uso resume de forma gráfica o que cada um dos
atores envolvidos pode fazer, e com a modelagem conceitual entendemos melhor como o projeto deve ser estruturado. A cada passo nos
aproximamos mais do código.

Referências
BARNES, David J.; KÖLLING, Michael. Programação orientada a objetos com
Java: uma introdução prática usando o BlueJ. São Paulo: Pearson, 2010.
FOWLER, Martin. UML essencial: um breve guia para a linguagem-padrão de
modelagem de objetos. Porto Alegre: Bookman, 2005.

86

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Indicamos que o personagem Kramula pertence a um mundo diferente do de Astroldo. Embora compartilhem o mesmo tipo de terreno
(campo), os mundos Terra Média e Lugar Nenhum têm climas diferentes. Outra informação interessante é que o mundo Lugar Nenhum tem
um Animal, o Dogin, que ainda não foi domesticado, pois não há uma
ligação dessa instância com o personagem.

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Capítulo 7

Diagramas
de classe

Quando desenvolvemos jogos, a principal forma de documentação é
o Game Design Document (GDD), que contém história, personagens, de­
talhes sobre a mecânica do jogo, etc. Esse documento é criado por pro­
fissionais de diferentes áreas e serve para orientar toda a equipe – pro­
gramadores, artistas, designers, produtores, testadores, compositores,
sound designers e redatores (ROGERS, 2018). Com o GDD, os programa­
dores conseguem entender todo o contexto do jogo e contribuir regis­
trando requisitos com FURPS+ e até mesmo casos de uso. Não é muito
comum encontrar muitos detalhes em um GDD, visto que se trata de um
documento geral que toda a equipe utiliza para guiar o desenvolvimento
de jogos. Porém, para um bom desenvolvimento, precisamos ir além.
Neste capítulo, daremos mais um passo no design de aplicações
orientadas a objetos. Vamos conhecer com mais detalhes os diagra­
mas de classe e como eles viram código em nosso projeto.
87

No capítulo 3, quando discutimos o que é herança, vimos um diagra­
ma de classe. Mas o que é mesmo essa representação gráfica e qual
seu objetivo?
Como o diagrama de casos de uso, o diagrama de classe faz parte
da UML e visa representar graficamente as classes do nosso sistema –
seus atributos, seus métodos – e como elas se relacionam com outras
classes. Esse tipo de diagrama nos deixa a um passo da implementação,
pois a partir dele conseguimos começar a criar nossas classes (PAGE­
‑JONES, 2001; FOWLER, 2005). Vamos olhar de perto, na figura 1, os
itens de um diagrama de classe.
Figura 1 – Exemplo de diagrama de classes

Personagem
+ id: int
+ nome: String
+ tipo: String
+ amigos: [Animal]

Animal

0..*

Animal
+ id: int
+ apelido: String
+ especie: String

+ AdicionarAmigo(animal: animal): void
+ Amigos():[Animal]

A figura 1 é simples e tem por objetivo demonstrar alguns primei­
ros elementos visuais do diagrama de classes. Nela temos uma classe
Personagem e uma classe Animal. A classe Personagem tem um atribu­
to “id” do tipo “int”, e o símbolo de adição (+) indica que esse atributo é
público. Outros atributos públicos dessa classe são “nome” e “especie”
(sim, devemos escrever o nome dos atributos e classes sem acentuação
e, se for o caso, sem cedilha). O atributo “amigos” está com o sinal de
subtração (–), que indica que ele é privado. Além disso, esse atributo é
um vetor de Animal. Note que esse é o nome da outra classe, ou seja, um
personagem contém uma coleção/conjunto de animais, mas, antes de

88

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

1 Introdução aos diagramas de classe

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

falarmos desse relacionamento, observe que, na parte inferior da clas­
se Personagem, temos outro conjunto de elementos, os métodos. Essa
classe possui os métodos AdicionarAmigo e Amigos. O método para adi­
cionar um novo amigo recebe como parâmetro uma instância da classe
Animal, e o método Amigos devolve/retorna um vetor de elementos do
tipo Animal.
Embora no diagrama não tenhamos os detalhes de implementação,
nomes com sentido evidente nos orientam na hora de programar. No
método Amigos, já consigo imaginar que devo retornar o valor do atri­
buto “amigos”, já que ambos têm o mesmo nome e tipo. Já o méto­
do AdicionarAmigo me indica que devo colocar a instância que recebi
como parâmetro no vetor “amigos”.
Logo mais veremos como esse diagrama pode ser implementado
em C#, mas antes vamos falar do relacionamento entre as duas classes.
A classe Animal tem uma seta que sai dela e se liga à classe Personagem,
com multiplicidade “0..*” (ou seja, um personagem tem zero ou mais
animais). Esse mesmo relacionamento é indicado pelo atributo “ami­
gos” da classe Personagem, portanto seria redundante colocar o atri­
buto. Nesse exemplo o atributo apareceu porque queremos deixar claro
que ele deve ser privado, mas alguns analistas omitiriam o atributo da
classe Personagem.
Veja como seria um código em C# para o diagrama da figura 1.
1
2

using System;

3

class Animal {

4

public int id;

5

public String apelido;

6
7

public String especie;
}

8
9

class Personagem {

10

public int id;

Diagramas de classe

89

public String nome;

12

public String tipo;

13

private Animal[] amigos;

14
public void AdicionarAmigo(Animal animal) { /* código
omitido */ }

15
16
17

public Animal[] Amigos() { /* código omitido */

}

}

O código está fiel ao diagrama, porém, por conta da linguagem esco­
lhida, C#, precisamos de outros elementos, além das implementações
dos métodos das linhas 15 e 16, que não fazem parte do diagrama.
Em C# todo vetor precisa ser inicializado para ser usado. Por isso
precisamos de um construtor na classe Personagem.
1
2
3

public Personagem() {
amigos = new Animal[0];
}

Esse construtor inicializa o vetor de animais com zero elementos, já
que inicialmente um personagem terá zero amigos em nosso jogo. Em
C#, para retornar os amigos temos duas opções: implementar o método
Amigos ou modificar a linha 13 da declaração e apagar a linha 16. Veja
como seriam as duas opções:
IMPLEMENTAÇÃO DO MÉTODO “AMIGOS”

16

public Animal[] Amigos()
{

17
18

MODIFICANDO A LINHA 13

13


public
Animal[] Amigos {
get; private set; }

return amigos;18.
}

A implementação completa para a classe Personagem pode ser vis­
ta a seguir, incluindo o método AdicionarAmigo(Animal animal).
9
10
11

90

class Personagem {
public int id;
public String nome;

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

11

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

12

public String tipo;

13

public Animal[] Amigos { get; private set; }

14
15

public Personagem() {

16

Amigos = new Animal[0];

17

}

18
19

public void AdicionarAmigo(Animal animal) {

20

int novoTamanho = Amigos.Length + 1;

21

Animal[] novosAmigos = new Animal[novoTamanho];

22
23

for (int i = 0; i < Amigos.Length; i++) {

24

novosAmigos[i] = Amigos[i];

25

}

26
27

novosAmigos[novoTamanho - 1] = animal;

28
29
30

Amigos = novosAmigos;
}
}

O método AdicionarAmigo é público, e em seu lugar deve ser usa­
do o set de Amigos, porque precisamos implementar uma lógica para
adicionar um novo amigo. Nesse caso, criamos um vetor com um ele­
mento a mais (linhas 20 e 21), copiamos o vetor original para o novo
vetor (linhas 23 a 25), adicionamos o novo amigo/animal ao novo vetor
(linha 27) e então atualizamos os amigos do personagem com o novo
vetor (linha 28). Nessa lógica, não testamos se o animal que está sendo
inserido já está na lista. Assim, quem usar nossa classe Personagem
poderá adicionar mais de uma vez o mesmo Animal.
Você saberia como testar isso? Basta adicionar uma lógica no início
do método que varre todo o vetor de amigos, verificando se já existe
um Animal com o mesmo “id” da variável recebida como parâmetro.
Se você encontrá-lo, basta dar um “return” e o método para sua execu­
ção. Não modificamos a lista, caso contrário a nossa lógica atual será
executada. Note que essa lógica não faz parte do diagrama de classes

Diagramas de classe

91

tamento de requisitos em FURPS+, ou essa descrição pode não existir.
Mesmo planejando, algumas coisas podem ficar em aberto, por isso é
preciso ter bom senso e discutir com a equipe para decidir o que fazer.
No nosso diagrama o personagem possui um atributo “tipo”, e esta­
mos considerando que todos os personagens têm os mesmos atributos
e comportamentos. Mas imagine que o nosso jogo tenha dois tipos de
personagem: humanos e fadas. Humanos se comportam como uma
pessoa comum: conseguem correr, pular, fazer amigos. Já as fadas não
correm, mas voam. Uma forma de representar essas classes seria atra­
vés da herança e do polimorfismo, que vimos no capítulo 3. Um possível
diagrama para esse caso é apresentado na figura 2.
Figura 2 – Exemplo de herança

Personagem

Animal

+ id: int
+ nome: String
+ tipo: String
+ amigos:[Animal]

0..*

+ id: int
+ apelido: String
+ especie: String

+ AdicionarAmigo(animal: animal): void
+ Amigos(): [Animal]

Humanos

+ Correr():void
+ Pular():void

Fada

+ Voar():void

No diagrama de classes da UML, a herança é representada por um
relacionamento entre duas classes, com uma linha que liga a subclasse
92

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

apresentado. Esse tipo de restrição pode estar descrita no nosso levan­

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

com a classe pai e uma seta vazada, diferentemente do relacionamento
entre Personagem e Animal, que usa uma seta aberta para representar
uma associação simples (BARNES; KÖLLING, 2010).
Note que, no exemplo, humanos e fadas herdam de Personagem
seus atributos e métodos. Logo, humanos e fadas têm “id”, “nome” e
um conjunto de “amigos” que são do tipo Animal. Ambos podem fazer
novos amigos (método AdicionarAmigo), listar os amigos feitos (mé­
todo Amigos) e andar. Os humanos podem também correr e pular, e as
fadas podem voar. Com base no nosso último código do Personagem,
removemos a linha 12, que é o atributo “tipo”, e acrescentamos as se­
guintes classes:
1
2

class Humano: Personagem {
public void Correr () {/* codigo omitido */}

3
4

public void Pular () {/* codigo omitido */}
}

5
6

class Fada: Personagem {

7
8

}

public void Voar () {/* codigo omitido */}

Essas são as classes herdeiras de Personagem apresentadas no dia­
grama da figura 2. O código a seguir mostra uma forma de usar as duas
classes em C#. O primeiro código cria um personagem humano, e o
segundo uma fada. Se você executar esses códigos, verá que as saídas
diferem dependendo de quem foi instanciado.
1
2

class Programa {
static void Main() {

3

Personagem p = new Humano(){
id = 1, nome = “Glory”};

4
5
6

Diagramas de classe

if(p is Humano) {
Console.WriteLine(
{0} é humano e sabe correr
e pular”, p.nome);

93

} else {
Console.WriteLine(
“{0} é fada e sabe voar”,
p.nome);

8
9

}

10
11

}
}
Saída: Glory é humano e sabe correr e pular

12
13

class Programa {
static void Main() {
Personagem p = new Fada(){
id = 1, nome = “Glory”};

14
15
16

if(p is Humano) {
Console.WriteLine(
“{0} é humano e sabe correr
e pular”, p.nome);

17
18

} else {
Console.WriteLine(
“{0} é fada e sabe voar”,
p.nome);

19
20
21
22

}
}
}
Saída: Glory é fada e sabe voar

Quando criamos uma variável do tipo Personagem (linha 3), mas a
instância é do tipo da subclasse, se quisermos usar qualquer atributo ou
método da subclasse, precisamos ter certeza de qual é seu tipo. Para
isso, temos em C# o operador “is”, que retorna “verdadeiro” se o tipo da
subclasse for o mesmo da classe, e ”falso” se não for (MICROSOFT, 2022).
Utilizamos o diagrama de classes para definir quais serão as clas­
ses e como elas se relacionam. Esse processo de design deve consi­
derar dois pontos importantes: a coesão e o acoplamento (BARNES;
KÖLLING, 2010).

94

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

7

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

A coesão diz respeito a colocar nas classes somente os atributos e
os métodos que façam sentido. Por exemplo, poderíamos colocar no
objeto personagem um método para calcular o dano de um ataque so­
frido ao enfrentar um inimigo, mas será que faria sentido o próprio per­
sonagem calcular o tamanho do dano sofrido? Para isso ele teria que
saber que tipo de instrumento o inimigo usou, a força aplicada, o local
do golpe, etc., ou seja, ter toda a lógica necessária para fazer esse cál­
culo. Colocar esse método no inimigo também não faz muito sentido.
É possível seguir um desses dois caminhos? Sim, mas podemos esco­
lher um que faça mais sentido, por exemplo, criar uma terceira classe
Arena que conheça o personagem e seu inimigo e saiba ler seus atribu­
tos. A arena é a classe mais adequada para decidir quanto de vida seu
personagem deve perder ao sofrer o ataque de um inimigo.
O acoplamento se refere a uma classe ter que conhecer a outra, à
relação entre classes. No diagrama da figura 2, o Personagem tem que
conhecer o Animal, e as classes Humano e Fada têm que conhecer o
Personagem, ou seja, estarem acopladas. Quanto maior o acoplamen­
to, mais difícil é reutilizar o código em outros projetos ou até mesmo
em um contexto diferente dentro do mesmo jogo. A classe Animal, por
exemplo, não está acoplada a ninguém em nosso diagrama da figura 2,
por isso é mais fácil reutilizá-la. No capítulo 8, veremos padrões de pro­
jetos, que vão te ajudar a entender melhor esses dois pontos.

2 Exemplos de uso em ambiente de jogos
digitais
Para exemplificar o uso de diagrama de classes em jogos digitais,
tomaremos como base um jogo 2D de plataforma simples, feito em
Unity3D (UNITY, 2022).1 Considere o diagrama da figura 3.

1 Código completo disponível em: https://github.com/joaquimp/SENAC_JogoPlataforma2D/releases/tag/
v1.0. Acesso em: 24 maio 2023.

Diagramas de classe

95

Animator

Transform

...

+ position: Vector3D
+ localScale: Vector3D

+ SetFloat(property: String, value: float): Void

Input
...

Rigidbody2D

MonoBehaviour

+ velocity: Vector2D

+ transform: Transform
+ Start(): Void
+ Update(): Void

GetKey(key: KeyCode): bool
tem

tem

usa

Personagem
+ velocidade: float
+ ativo: bool
# rigidBody: Rigidbody2D
# faceDireita: bool
# animator: Animator

CameraController

tem/usa

+ EscolherPersonagem1 ( ): void
+ EscolherPersonagem2 ( ): void
+ SeguirPersonagem( ): void

+ MoverDireita(): void
+ MoverEsquerda(): void
+ Virar(): void

Abelha

96

+ personagem1: Personagem
+ personagem2: Personagem
– personagemAtual: Personagem

Coelho

+ velocidadeVertical: float

+ alturaPulo: float

+ Voar( ): void
+ Descer( ): void

+ Pular(forca: float): void

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Figura 3 – Diagrama de classes para um jogo de plataforma na Unity3D

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Nesse diagrama, as classes em azul pertencem à biblioteca da
Unity e não foram totalmente representadas. Temos somente os atri­
butos e métodos que utilizaremos no nosso código. Essas classes são
bem mais completas e possuem diversos outros atributos e métodos.
As classes em laranja são as nossas classes, específicas do nosso jogo.
A principal classe da Unity é a MonoBehaviour, e toda classe des­
te tipo pode ser incluída em um GameObject. Resumidamente, um
GameObject é qualquer objeto na cena do jogo, desde um player até um
elemento estético que não tem ação. Essa classe possui os métodos
Start e Update. O primeiro é chamado uma única vez, quando o objeto
[e colocado na cena pela Unity, e o segundo é chamado a cada frame do
jogo, ou seja, um jogo que rode a 60 fps (frames por segundo) chamará
o método Update de cada GameObject sessenta vezes a cada segundo.
Bem rápido, não? Por isso não coloque códigos complexos dentro dele.
As nossas classes Personagem e CameraController são herdeiras de
MonoBehaviour. Assim, podemos dizer que esses nossos scripts são
MonoBehaviour, e ambos possuem os métodos Start e Update, além de
podermos atribuí-los a qualquer GameObject.
Na classe Personagem, colocaremos todo o comportamento co­
mum de nossos personagens. Para esse exemplo, todos os persona­
gens podem se movimentar para a direita e para a esquerda e virar (o
que significa que o personagem vai se virar para o lado que está an­
dando). Para ficar mais claro, a figura 4 ilustra um frame do jogo já em
funcionamento, no qual o coelho e a abelha estão olhando para a direita.

Diagramas de classe

97

A abelha é um Personagem que também pode voar (ir para cima) ou
descer (ir para baixo) usando as setas do teclado. Já o coelho não voa
nem desce, mas pode pular, uma ação que vai além do Personagem,
mas que também não existe na abelha. Por isso, no nosso diagrama,
ambas as classes, Abelha e Coelho, herdam de Personagem. Logo,
Abelha e Coelho são Personagem e são MonoBehaviour.
A classe CameraController tem por objetivo controlar a câmera e de­
finir qual personagem está ativo. Note que na classe Personagem existe
o atributo “ativo”: se verdadeiro, o personagem se movimentará; caso
contrário, ele não obedecerá aos comandos.
As outras classes da Unity que usaremos são listadas a seguir.
• Input: verifica, através do método GetKey, se o usuário está pres­
sionando alguma tecla.
• Rigidbody2D: faz um GameObject obedecer às leis da física.
Mudar a física do jogo pode gerar efeitos legais. Esse componen­
te também permite aplicar uma velocidade ao objeto a que está
vinculado, basta alterarmos o valor do atributo “velocity”.
98

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Figura 4 – Tela do jogo de exemplo

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

• Animator: não é o foco deste livro tratar esse componente, mas
sua função é basicamente controlar as animações do nosso per­
sonagem. Para facilitar, ele já está pronto no nosso projeto e, se
passarmos o valor de velocity do nosso Rigidbody2D como parâ­
metro, usando o método SetFloat, nosso coelho mudará do esta­
do de parado para andando se a velocidade for maior que zero, e
ficará parado se for igual a zero.
• Transform: todo MonoBehaviour possui um Transform, objeto que
nos permite mudar a posição x, y e z através de um Vector3D e
mudar a escala. Utilizaremos o localScale para mudar a direção
do nosso personagem. Se colocarmos uma escala positiva em x,
nosso personagem olhará para a direita; se o valor for negativo,
ele olhará para a esquerda. Essa é uma técnica muito usada para
evitar deixar o jogo pesado, com muitas imagens.
Agora que já vimos o que significa cada uma das classes, vamos
aos relacionamentos mais importantes. Todo Personagem possui um
Rigidbody2D e um Animator, e utiliza o Input para controlar o movimen­
to. Já a classe CameraController possui três instâncias de personagem:
personagemAtual, personagem1 e personagem2 (os dois últimos são
públicos). Lembre-se que na Unity todo atributo público aparece no edi­
tor, onde conseguimos mudar seu valor. O personagem1 terá uma refe­
rência a uma instância de Abelha, e o personagem2 terá uma referência
a uma instância de Coelho. Já o personagemAtual terá valor inicial igual
ao personagem1 e mudará de valor toda vez que trocarmos de persona­
gem, ou seja, o personagemAtual vai se referir ao personagem que esta­
mos controlando no momento. A seguir estão os principais elementos
do código da classe CameraController (a classe na íntegra você pode
conferir no Anexo I deste capítulo):

Diagramas de classe

99

public class CameraController : MonoBehaviour {
Personagem personagemAtual;

3

public Personagem personagem1;

4

public Personagem personagem2;

5
6

void Start() { ... }

7

void Update() { ... }

8

void EscolherPersonagem1() { ... }

9

void EscolherPersonagem2() { ... }

10
11

void SeguirPersonagem() { ... }
}

Note que nas linhas de 6 a 8 os três atributos do tipo Personagem
são declarados, conforme comentado anteriormente. Veja a versão re­
sumida do código da classe Personagem (classe completa no Anexo
II deste capítulo):
1

public class Personagem : MonoBehaviour {

2

public float velocidade;

3

protected Rigidbody2D rb;

4

protected Animator animator;

5

protected bool faceDireita = true;

6

public bool ativo = true;

7
8

protected void Start() { ... }

9

protected void Update() { ... }

10

void MoverDireita() { ... }

11

void MoverEsquerda() { ... }

12
13

void Virar() { ... }
}

Na classe Personagem, o método Update verifica se um dos coman­
dos básicos de um personagem foi acionado e, se sim, chama o método
específico. Note que essas duas últimas classes, CameraController e
Personagem, herdam de MonoBehaviour.
Agora precisamos escrever as classes Abelha e Coelho, que devem
herdar de Personagem. Veja os principais elementos destas classes
(versão completa no Anexo III):
100

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

1
2

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

1
2

public class Abelha : Personagem {
public float velocidadeVertical;

3
4

void Update() { ... }

5

public void Voar() { ... }

6
7

}

public void Descer() { ... }

1
2

public class Coelho : Personagem {
public float alturaPulo;

3
4
5
6

void Update() { ... }
void Pular() { ... }
}

Uma das vantagens dessa modelagem é que ela nos permite criar
personagens com habilidades diferentes. Basta criar uma subclasse
de Personagem e fazer as implementações adicionais. Se você quiser
também adicionar um novo comportamento comum a todos os perso­
nagens, basta alterar a classe Personagem.

Considerações finais
Neste capítulo vimos que o diagrama de classes é um documento
muito útil, que traz uma visão geral de estrutura e de relacionamentos, e
que pode ser convertido em código de modo bastante intuitivo.
Com o exemplo apresentado na Unity pudemos perceber as vanta­
gens de um código bem arquitetado. Para entender ainda mais como
melhorar nosso código, no próximo capítulo abordaremos padrões de
projeto, que nada mais são do que boas práticas de programação cata­
logadas ao longo dos anos. Essas práticas nos ajudam a resolver pro­
blemas com o nosso diagrama de classes.

Diagramas de classe

101

BARNES, David J.; KÖLLING, Michael. Programação orientada a objetos com
Java: uma introdução prática usando o BlueJ. São Paulo: Pearson, 2010.
FOWLER, Martin. UML essencial: um breve guia para a linguagem-padrão de
modelagem de objetos. Porto Alegre: Bookman, 2005.
MICROSOFT. Operadores de teste de tipo e expressões de conversão: is, as
e typeof conversões. Microsoft Learn, 2022. Disponível em: https://learn.
microsoft.com/pt-br/dotnet/csharp/language-reference/operators/typetesting-and-cast. Acesso em: 28 dez. 2022.
PAGE-JONES, Meilir. Fundamentos do desenho orientado a objetos com UML.
São Paulo: Makron Brooks, 2001.
ROGERS, Scott. Level UP: um guia para o design de grandes jogos. São Paulo:
Blucher, 2018.
UNITY. Página inicial. Unity, [s. d.]. Disponível em: https://unity.com/. Acesso
em: 20 dez. 2022.

102

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Referências

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Anexos
Anexo I
1
2

using System.Collections;
using System.Collections.Generic;

3

using UnityEngine;

4
5

public class CameraController : MonoBehaviour {

6

Personagem personagemAtual;

7

public Personagem personagem1;

8

public Personagem personagem2;

9
10

void Start() {

11

		

personagemAtual = personagem1;

12

		

personagem1.ativo = true;

13

		

personagem2.ativo = false;

14

}

15
16

void Update() {

17

		
if (Input.GetKey(KeyCode.Alpha1))
EscolherPersonagem1();

18

		
if (Input.GetKey(KeyCode.Alpha2))
EscolherPersonagem2();

19

		SeguirPersonagem();

20

}

21
22

void EscolherPersonagem1() {

23

		

personagemAtual = personagem1;

24

		

personagem1.ativo = true;

25

		

personagem2.ativo = false;

26

}

27
28

void EscolherPersonagem2() {

29

		

personagemAtual = personagem2;

30

		

personagem1.ativo = false;

Anexos

103

		

32

}

personagem2.ativo = true;

33
34

void SeguirPersonagem() {

35

		

36

			personagemAtual.transform.position.x,

37

			
personagemAtual.transform.position.y + 2.7f,
-10);

38
39

transform.position = new Vector3(

}
}

Anexo II
1
2

using System.Collections;
using System.Collections.Generic;

3

using UnityEngine;

4
5

public class Personagem : MonoBehaviour {

6

public float velocidade;

7

protected Rigidbody2D rb;

8

protected Animator animator;

9

protected bool faceDireita = true;

10

public bool ativo = true;

11
12

protected void Start() {

13

		

rb = GetComponent<Rigidbody2D>();

14

		

animator = GetComponent<Animator>();

15

}

16
17
18

protected void Update() {
		
animator.SetFloat("velocidade", System.Math.
Abs(rb.velocity.x));

19
20

		
//Para a execução se o personagem estiver
desativado

21

		

22

		
if (Input.GetKey(KeyCode.RightArrow))
MoverDireita();

104

if (!ativo) return;

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

31

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

23

		
if (Input.GetKey(KeyCode.LeftArrow))
MoverEsquerda();

24

		Virar();

25

}

26
27

void MoverDireita() {

28

		
rb.velocity = new Vector2(velocidade,
rb.velocity.y);

29

		

30

}

faceDireita = true;

31
32

void MoverEsquerda() {

33

		
rb.velocity = new Vector2(-velocidade,
rb.velocity.y);

34

		

35

}

faceDireita = false;

36
37

void Virar() {

38

		if (faceDireita)

39

			
this.transform.localScale = new Vector3(1, 1,
1);

40

		else

41

			
this.transform.localScale = new Vector3(-1,
1, 1);

42
43

}
}

Anexo III
Classe Abelha

1
2

using System.Collections;
using System.Collections.Generic;

3

using UnityEngine;

4
5
6

public class Abelha : Personagem {
public float velocidadeVertical;

7
8

void Update() {

Diagramas de classe

105

		
base.Update(); //chama o Update da classe
Personagem

10
11

		

if (!ativo) return;

12

		

if (Input.GetKey(KeyCode.UpArrow)) Voar();

13

		

if (Input.GetKey(KeyCode.DownArrow)) Descer();

14

}

15
16
17

public void Voar() {
		
rb.velocity = new Vector2(rb.velocity.x,
velocidadeVertical);

18

}

19
20
21
22
23

public void Descer() {
		
rb.velocity = new Vector2(rb.velocity.x,
-velocidadeVertical);
}
}
Classe Coelho

1
2

using System.Collections;
using System.Collections.Generic;

3

using UnityEngine;

4
5

public class Coelho : Personagem {

6

public float alturaPulo;

7
8
9

void Update() {
		base.Update();

10
11

		

if (!ativo) return;

12

		

if (Input.GetKeyDown(KeyCode.Space)) Pular();

13

}

14
15
16
17
18

106

void Pular() {
		
rb.velocity = new Vector2(rb.velocity.x,
alturaPulo);
}
}

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

9

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Capítulo 8

Introdução a
padrões de projetos

Se você visitar a biblioteca da sua cidade e entender como os livros
estão organizados, provavelmente você poderá visitar as bibliotecas
das cidades vizinhas sem precisar aprender novamente sobre essa organização. Isso porque as bibliotecas têm um padrão para organizar os
livros. Em geral, eles recebem um código que os identifica e são separados por assunto, sobrenome do autor e título.
107

diferentes em bibliotecas diferentes, porque quem faz essa classificação é o bibliotecário. Esse trabalho precisa ser cuidadoso e seguir o
padrão, para que os usuários da biblioteca encontrem facilmente o que
procuram.
Isso vale também para a programação. Na maioria dos projetos, escrevemos códigos em que outras pessoas vão mexer, ou nós mesmos
mexemos em códigos de outras pessoas. Assim, é necessário padronizar o código para que quem dê continuidade ao trabalho ou faça manutenções não perca muito tempo tentando entender o que foi feito. E, ah,
mesmo que trabalhe sozinho, você vai perceber que também precisa de
padrões. Muitas vezes, você pode se esquecer do que fez ou chegar a
uma situação muito complexa, difícil de ser solucionada.
Neste capítulo entenderemos melhor o que são padrões, como eles
são criados e organizados, e veremos alguns exemplos.

1 Padrões de projetos
Quando projetamos sistemas usando a programação orientada a
objetos, nosso objetivo é criar um código que funcione da maneira esperada, sem erros, e que possa ser facilmente mantido ou melhorado.
Mas como alcançamos esse objetivo? Vimos anteriormente que com
um bom levantamento de requisitos e algumas ferramentas de UML,
conseguimos criar um modelo de domínio que expressa um contexto
específico do problema que estamos resolvendo. Partir do diagrama de
domínio para o código não é somente descrever os métodos e atributos
(LARMAN, 2011).
Na arquitetura, o autor Christopher Alexander criou uma definição
de padrão ao perceber que bons projetos arquitetônicos tinham soluções em comum para problemas parecidos. Com base nessa ideia de

108

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Mas quem faz tudo isso? Bem, o mesmo livro pode ter números

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Alexander e adaptando-a à área da computação, Sommerville (2011)
define o padrão em desenvolvimento de software do seguinte modo:
O padrão é uma descrição do problema e da essência de sua solução, de modo que a solução possa ser reusada em diferentes contextos. O padrão não é uma especificação detalhada. Em vez disso,
você pode pensar nele como uma descrição de conhecimento e
experiência, uma solução já aprovada para um problema comum.
[...] Além de serem soluções já testadas para problemas comuns,
[os padrões] tornam-se um vocabulário para falar sobre um projeto.
Você pode, portanto, explicar seu projeto por meio de descrições
dos padrões que você usou.

Antes de falar dos 23 padrões de projeto originalmente catalogados
pela chamada Gangue dos Quatro (GoF, do inglês Gang of Four),1 Larman
(2011) descreve os padrões GRASP (General Responsibility Assignment
Software Patterns), uma lista de boas práticas para quem quer programar com responsabilidade. O autor destaca que esses padrões servem
para o aprendizado de quem quer criar projetos orientados a objetos, e
que, depois de dominar os nove princípios GRASP, saber de cor o nome
deles se torna irrelevante. Esses nove princípios são explicados a seguir.
• Controlador: nossos sistemas precisam de alguma interface com
o usuário que gere eventos e, para organizar a forma de receber e
processar esses eventos, criamos classes controladoras. Como
porta de entrada, uma classe-controle deve saber para quais outras classes encaminhar uma solicitação a fim de que ela seja
respondida corretamente. Por exemplo, se o jogador chegar a um
ponto de checagem e salvamento (checkpoint), a classe-controle
receberá a informação e fará o direcionamento para a classe que
lida com o salvamento do do jogo, para que salve o estado atual
e, caso o jogador morra, ele possa voltar a esse ponto. A classe

1 O nome Gangue dos Quatro faz referência aos autores de Padrões de projeto: Erich Gamma, Richard Helm,
Ralph Johnson e John Vlissides.

Introdução a padrões de projetos

109

mente o princípio de alta coesão, para evitar uma controladora gigante em seu projeto.
• Criador: esse princípio define quem deve ser responsável por criar
uma instância de uma classe. Por exemplo, em um jogo, uma instância da classe Personagem deve ser criada em que momento e
por qual classe? Podemos definir que temos uma classe controladora chamada GameManager, e que, ao chamarmos o método
NewGame, uma instância de Personagem é criada. O princípio
do criador evidencia que toda classe deve ser instanciada em algum momento, e que é preciso definir claramente de quem é essa
responsabilidade.
• Especialista na informação: este princípio nos orienta a atribuir
a responsabilidade das ações do nosso sistema às classes que
possuem a informação. Por exemplo, se uma classe tem a informação sobre a vida e a armadura de um personagem, podemos
atribuir a ela a responsabilidade de calcular o dano sofrido pelo
personagem ao receber o golpe de um inimigo, já que é essa classe que detém as informações necessárias para realizar o cálculo
e alterar os dados de vida de um personagem.
• Acoplamento baixo: o acoplamento de uma classe é a medida do
quanto ela depende de outras. O baixo acoplamento de um objeto
significa que ele depende de poucos ou de nenhum outro objeto.
O alto acoplamento pode gerar problemas, pois modificar uma
classe altamente acoplada pode exigir que modifiquemos as outras classes a que ela está ligada, e se torna mais difícil entender
e reutilizar os objetos. No entanto, esse princípio não visa ensinar
a diminuir o acoplamento, mas sim a medi-lo e a alterar nosso
projeto em caso de alto acoplamento.
• Coesão alta: ao seguir o princípio “especialista na informação”, podemos acabar colocando muitas responsabilidades em uma única
110

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

controladora pode gerir mais de um evento, mas é preciso ter em

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

classe, muitas vezes sem coesão com seu objeto. Classes com
baixa coesão possuem responsabilidades que não fazem muito sentido para elas. Por exemplo, a classe Personagem pode ter
como responsabilidade calcular os danos sofridos pelo personagem, porém, embora haja relação entre esse cálculo e o objeto, faz
mais sentido ter outro objeto que use os dados do personagem e
do ataque para decidir sobre o dano sofrido. Isso porque, no nosso
domínio, a classe Personagem visa representar um personagem
do jogo, o que já é muita coisa. Além disso, se os inimigos sofrem
dano, teremos códigos semelhantes espalhados no projeto.
• Polimorfismo: este princípio, que já estudamos no capítulo 3, refere-se à sobrescrita e à sobreposição de métodos, com ou sem
uso de herança. O polimorfismo diz respeito ao comportamento
distinto de um objeto a depender de seu tipo-base e à criação de
componentes interconectáveis (como fizemos no capítulo 7, na
escolha da subclasse de Personagem).
• Invenção pura: como o nome sugere, este princípio nos orienta a
criar/inventar classes que não existem no nosso domínio, com a
finalidade de aumentar a coesão. Muitas vezes precisamos colocar um comportamento numa classe do domínio, mas esse comportamento não faz muito sentido para ela, o que fere o princípio
da coesão. Para evitar isso, inventamos uma classe para implementar nela esse comportamento.
• Indireção: o objetivo desse princípio é solucionar o problema de alto
acoplamento entre dois objetos. Se um objeto tem que conhecer
outro, isso aumenta o acoplamento. Uma possibilidade, então, é
criar uma classe intermediária que conheça os objetos envolvidos,
mas estes não precisam conhecer a classe intermediária – assim,
somente ela estará acoplada. Por exemplo, no cálculo de quanto
um personagem ou um inimigo deve perder de vida, podemos criar
uma classe que conhece os objetos personagem e inimigo e tenha
um método que recebe a instância dos envolvidos. Assim, essa
Introdução a padrões de projetos

111

estar acoplado à classe Inimigo (e vice-versa).
• Variações protegidas: esse princípio visa projetar objetos que não
sofram com a variação ou a instabilidade causada por objetos
acoplados. Por exemplo, na versão beta de um jogo, foram projetados dois tipos de inimigos, mas em versões futuras desejamos
acrescentar mais tipos de inimigos. Saber disso fará com que
possamos projetar melhor a ligação do nosso jogo com o objeto
Inimigo, visto que este pode variar e causar instabilidade.

IMPORTANTE
Como observa Larman (2011), “GRASP é relevante, mas, por outro lado,
é apenas uma ajuda ao aprendizado para estruturar e denominar os princípios – quando você ‘dominar’ os fundamentos, os termos GRASP específicos (Especialista na informação, Criador...) não são importantes”.

Comece aplicando pelo menos alguns dos nove princípios GRASP.
Você pode começar pela alta coesão e o baixo acoplamento. Esses dois
princípios, para serem alcançados, vão mostrar que você precisa olhar
para os outros sete. Além disso, os princípios de alta coesão e baixo
acoplamento nos ajudam a criar códigos que são mais fáceis de entender e de serem mantidos.

PARA SABER MAIS
Para conhecer mais a fundo os padrões GRASP, você pode ler os capítulos 17 e 25 do livro Utilizando UML e padrões, de Craig Larman (2011).

Mas como colocar em prática esses princípios? Como mencionado
anteriormente, a chamada Gang of Four (GoF) (GAMMA et al., 2007)
112

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

classe pode calcular o dano a sofrer, e o Personagem não precisa

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

catalogou 23 padrões que nos ajudam a projetar melhor. Esses padrões
não foram criados, mas identificados e catalogados como boas práticas pelos quatro pesquisadores.
O que programadores mais experientes têm de diferente dos novatos? A conclusão de Gamma et al. (2007) é que programadores mais
experientes reaproveitam soluções que já deram certo no passado para
o problema que estão enfrentando no momento, enquanto iniciantes
não têm esse arcabouço de soluções para usar.
Por isso é importante catalogar problemas e soluções testadas com
base na experiência, de modo a ajudar novos desenvolvedores. Além
disso, com a catalogação, fica mais fácil comunicar como o sistema foi
projetado. Em vez de ter que explicar cada uma das classes, o desenvolvedor pode simplesmente dizer que usou um padrão Singleton para
resolver o problema. Isso é possível pois, na descrição de um padrão
GoF, temos a definição do problema e a descrição genérica da solução.
Assim, se conhecemos os padrões, já sabemos de qual problema se
trata e como ele foi solucionado pelo desenvolvedor.
Os padrões GoF são classificados em três grupos:
1. Criacionais: esses são padrões relacionados ao problema de criar
instâncias, pois nem sempre um simples comando new no C#
será suficiente. No caso de um jogo, por exemplo, se quisermos
criar um tipo de inimigo constantemente em um ponto do cenário
(e este deve ter seu nível de força e inteligência de acordo com o
nível atual do personagem), precisaremos criar o objeto e configurar seus parâmetros. Além disso, em jogos, a eficiência é muito
importante. Uma das técnicas para reduzir o uso de memória é
reaproveitar objetos que seriam destruídos e reconfigurá-los para
voltar à cena. Nesse exemplo, poderíamos usar mais de um padrão: um que define uma fábrica de criação, e outro para melhorar
a eficiência na criação.

Introdução a padrões de projetos

113

classes são estruturadas para permitir, em alguns casos, baixo
acoplamento ou alta coesão. Um exemplo seria o caso de querermos deixar nosso personagem trocar seu item de ataque. Todos
os itens são manuseados da mesma forma, mas animações,
dano, velocidade e outros atributos são diferentes. Com o padrão
Bridge, podemos separar a implementação de um item da sua definição e, com isso, trocar a implementação durante a execução,
ou seja, trocar o item do personagem.
3. Comportamentais: estes padrões têm por objetivo ajudar em problemas com o fluxo da informação entre objetos. Um exemplo
são os pontos de checagem de um jogo, em que o estado de vários objetos precisa ser salvo, para que, caso o personagem morra, ele volte àquele ponto no mesmo estado que estava quando
passou por lá. O padrão nesse caso é o Memento.
Um padrão é descrito por intenção, motivação, aplicabilidade, estrutura, participantes, colaborações, consequências, implementação,
exemplo de código e usos conhecidos. No capítulo 7 apresentamos
um jogo em que podemos alternar entre personagens. Usando esse
exemplo, vamos ver, a seguir, a descrição do padrão de projeto.
• Intenção: encapsular algoritmos e permitir trocá-los durante a
execução.
• Motivação: facilitar a manutenção, já que, no nosso caso, cada
algoritmo diz respeito a um tipo de personagem e como ele utiliza
os comandos de teclado para se movimentar (entenda também
como manutenção o acréscimo de mais personagens).
• Aplicabilidade: usar este padrão quando várias classes se relacionam e são acionadas da mesma forma, mas possuem comportamentos diferentes. No nosso jogo, temos várias classes que
representam personagens e, por estarem na Unity, têm o mesmo

114

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

2. Estruturais: os padrões desse grupo dizem respeito a como as

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

método Update para capturar o evento do teclado. O que muda é
a implementação desse método; assim, podemos usar o padrão
de aplicabilidade para que a classe do jogo não precise estar acoplada a cada personagem, mas somente à sua definição genérica, e deixar a estratégia em classes separadas.
• Estrutura: para ilustrar a estrutura, a figura 1 apresenta um diagrama de classes genérico, usando o padrão de projeto comportamental Strategy, e a figura 2 apresenta uma proposta específica
para nosso jogo.
Figura 1 – Estrutura do padrão Strategy

Contexto

Estrategia

Strategy

InterfaceContexto( )

InterfaceAlgoritmo( )

EstrategiaConcretaA
InterfaceAlgoritmo( )

EstrategiaConcretaB
InterfaceAlgoritmo( )

EstrategiaConcretaC
InterfaceAlgoritmo( )

Fonte: adaptado de Gamma et al. (2007).

Figura 2 – Estrutura do padrão Strategy aplicado ao jogo de exemplo

Jogo

Personagem

Strategy

Update ( )

Update ( )

Coelho
Update ( )

Introdução a padrões de projetos

Abelha
Update ( )

115

◦ Estrategia: interface que é conhecida pelo contexto e permite
desacoplar as estratégias concretas do Contexto. Esta interface define o método que será chamado pelo Contexto. No
nosso exemplo, a classe Personagem define que o método
Update terá estratégias diferentes de implementação.
◦ EstrategiaConcreta: são subclasses de Estrategia e implementam os algoritmos. No exemplo, são as classes Coelho e Abelha.
As duas implementam o método Update da sua forma.
◦ Contexto: contém uma referência para Estrategia, que na verdade deverá ser uma das classes EstrategiaConcreta. No nosso exemplo, o Jogo tem um atributo do tipo Personagem, mas
a instância pode ser Coelho ou Abelha e podemos alterar durante a execução do jogo.
• Colaborações
◦ Estrategia e Contexto estão acopladas, pois é o Contexto que
chama o(s) método(s) da classe Estrategia. O Contexto pode
chamar qualquer método que quisermos implementar em
nossa Estrategia, com ou sem parâmetros.
◦ Não cabe ao Contexto definir qual implementação de
Estrategia será usada. Essa informação vem de fora (cliente),
e cabe ao Contexto repassar as chamadas do cliente à classe
Estrategia.
◦ No nosso exemplo, podemos ter uma classe GameManager
que define qual Personagem queremos usar e atribui a subclasse de Personagem ao Jogo. Assim, toda vez que for atualizado (método Update), o jogo chamará o método Update da
estratégia escolhida.
• Consequências: este padrão tem vantagens e desvantagens.
Entre as vantagens, pode-se destacar que esse tipo de solução
116

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

• Participantes

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

evita escrever códigos com diversas estruturas condicionais
(como o if) e permite escolher a implementação desejada em
tempo de execução, ou seja, não precisamos compilar o código
para mudar a estratégia. Como ponto negativo, pode-se citar o
comprometimento do desempenho, visto que uma classe precisa delegar para outra a execução e, a depender da situação, isso
pode ser percebido pelo usuário. Além disso, aumentamos o número de objetos do nosso projeto, o que, se for feito de modo
desorganizado, pode confundir os desenvolvedores no momento
da manutenção.
Por se tratar de padrões mais extensos, não trataremos aqui da implementação, do exemplo de código e dos usos conhecidos.

PARA SABER MAIS
Você pode ler o texto original sobre o padrão Strategy em Padrões de
projetos (GAMMA et al., 2007, p. 292-300). No capítulo 5 do livro também são descritos todos os padrões comportamentais. Outra forma de
conhecer mais sobre padrões e formas de implementação é visitar o
site Refactoring.Guru ([s. d.]).

Os padrões GoF não se limitam ao Strategy. Como dito anteriormente, temos um catálogo com 23 padrões, que servem de base para outros
catálogos de padrões (por exemplo, os padrões J2EE, que ajudam desenvolvedores de aplicações distribuídas). Como destaca Sommerville
(2011), para melhorar a comunicação entre a equipe e a qualidade das
soluções, estudar e aplicar os padrões de projeto é de extrema importância, sobretudo porque todo projeto, mesmo que de início pareça bastante simples, costuma se tornar complexo rapidamente.

Introdução a padrões de projetos

117

Além de tornar nosso código mais profissional e facilitar sua manutenção, o estudo de padrões de projeto permite que programadores menos experientes conversem em alto nível com programadores experientes. Isso porque os padrões de projeto definem um vocabulário simples
para explicar problemas e soluções muitas vezes complexos.
Combinar os padrões de projeto também é algo importante, visto
que cada um deles tem uma função bem específica. Esses padrões são
aplicados para problemas de criação, estrutura e comportamento, e
nossas aplicações lidam com essas três categorias ao mesmo tempo.

Referências
GAMMA, Erich et al. Padrões de projeto: soluções reutilizáveis de software
orientado a objetos. Porto Alegre: Bookman, 2007.
LARMAN, Craig. Utilizando UML e padrões: uma introdução à análise e ao projeto orientados a objetos e desenvolvimento iterativo. Porto Alegre: Bookman,
2011.
REFACTORING GURU. Padrões de projeto. Refactoring Guru, [s. d.]. Disponível
em: https://refactoring.guru/pt-br/design-patterns. Acesso em: 3 jan. 2023.
SOMMERVILLE, Ian. Engenharia de software. 9. ed. São Paulo: Pearson, 2011.

118

Programação orientada a objetos com C#

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Considerações finais

Material para uso exclusivo de aluno matriculado em curso de Educação a Distância da Rede Senac EAD, da disciplina correspondente. Proibida a reprodução e o compartilhamento digital, sob as penas da Lei. © Editora Senac São Paulo.

Sobre o autor

Joaquim Pessôa Filho é graduado em ciência da computação pela
Universidade Presbiteriana Mackenzie e mestre em engenharia elétrica
pela mesma instituição, onde atualmente é professor. Desde 2013 atua
no projeto Apple Developer Academy da Universidade Presbiteriana
Mackenzie no ensino de desenvolvimento de aplicativos mobile, e desde 2019 é um Apple Distinguished Educator. Tem experiência na área de
ciência da computação, com ênfase em desenvolvimento web e mobile,
atuando principalmente com os seguintes temas: sistemas colaborativos, sistemas hipermídia e multimídia, objetos distribuídos, padrões
de projeto, WebLab (laboratório remoto), automação e telecomunicações. Além do Mackenzie, já lecionou também na Universidade Cruzeiro
do Sul.

121

